//CShape 1.12#include "CShape.h"#include "CDrawUtils.h"#include "CDocumentApp.h"#include "CCanvas.h"#include "MiniConstants.h"#include "CSwatch.h"//#include "CShapeAction.h"#include "CPosessions.h"#include "CScriptParser.h"#include "CScriptAction.h"// suz bunny include#include "CResStore.h"/* CShape * -----------------   Constructor; set start & end points */CShape::CShape(LStream *inStream) : LPane(inStream) {	Point temp;	temp.h = temp.v = 0;	sInfo = new CShapeStore();	sInfo->setStart(temp);	sInfo->setEnd(temp);	sInfo->setVisible(true);	sInfo->setMoveable(true);}/* CShape * -----------------   RT constructor */CShape::CShape(const CShapeInfo &shapeInfo) {Int32 page;	DM*  dM = ((CDocumentApp*) LCommander::GetTopCommander())->GetData();	sInfo = dM->newShapeStore();		sInfo->setStart(shapeInfo.start);	sInfo->setEnd(shapeInfo.end);	sInfo->setVisible(true);	sInfo->setMoveable(true);		//create a name.	LStr255 newName;	getNewShapeName(newName);	sInfo->setName(newName);			fillC = shapeInfo.fillC;	frameC = shapeInfo.frameC;	InitPane(shapeInfo.paneInfo);	((CCanvas*) GetSuperView())->getPage(page);	sInfo->setPage(page);	LPane *theSupe, *theSupe2;	theSupe = GetSuperView();	theSupe2 = theSupe->GetSuperView();	pos =  theSupe2->FindPaneByID(151);//ugh. BUNNY	posessed = false;}CShape::~CShape() {	//Hide();	//SetSuperCommander(GetTopCommander());	//::SndDisposeChannel(&mSoundChannel); WE're gonna need some deconstrucing here!	::SndDisposeChannel(mSoundChannel,true);	PutInside(nil); // remove it from window	((CDocumentApp *) GetTopCommander())->GetCPalettePtr()->setTargetShape(NULL);}/* FinishCreateSelf * -----------------   Add to the command hierarchy */void CShape::FinishCreateSelf() {	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);		SetSuperCommander(canvas);//	LStr255 *defaultPict, *empty = new LStr255(kEmptyString);	Str255 defaultPict;	LString::CopyPStr(kEmptyString, defaultPict);		sInfo->getPict(defaultPict);	if (::EqualString(defaultPict, kEmptyString, false, false)) {		LString::CopyPStr(kDefaultMenuItem, defaultPict);		sInfo->setPict(defaultPict);	}//	delete empty;	//sInfo->getVisible(visible);	//app->getCatalog()->UpdateShapes();		if (app->inPlay()) {		//sound shite		mSoundChannel = NULL;		OSErr err = ::SndNewChannel(&mSoundChannel, sampledSynth, 0, NULL);		//RunEnterScript();	}	highlighted = false;	isMoving = false;	}/* ShapeFrameRect * -----------------   Returns the exterior frame of the shape, which is a bit bigger than   the shape. */Rect CShape::ShapeFrameRect() {	Rect frame = ShapeRect();	::InsetRect(&frame,-(kKnobWidth/2.0),-(kKnobHeight/2.0));	return frame;}/* ShapeRect * -----------------   Returns the actual fram of the shape. */Rect CShape::ShapeRect() {	Rect frame;	Point start, end;	sInfo->getStart(start);	sInfo->getEnd(end);	CDrawUtils::CalcEnclosingRect(start, end,frame);	return frame;}/* DrawResizeKnobs * -----------------   Draw both knobs at once. */void CShape::DrawResizeKnobs() {	if (!((CDocumentApp*) LCommander::GetTopCommander())->inPlay()) {		DrawResizeKnobStart();		DrawResizeKnobEnd();	}}/* DrawResizeKnobStart,DrawResizeKnobEnd * -----------------   Draw individual knobs */void CShape::DrawResizeKnobStart() { 	Point start;	sInfo->getStart(start);	DrawKnobHelper(start);}void CShape::DrawResizeKnobEnd() { 	Point end;	sInfo->getEnd(end);	DrawKnobHelper(end); }/* DrawKnobHelper * -----------------   Decomped helper function to draw both knobs */void CShape::DrawKnobHelper(Point startingPoint) {	Rect knob;	Point knobStart = startingPoint;	Point knobEnd = knobStart;		// Expand start & end points	knobEnd.h += kKnobWidth / 2.0;	knobEnd.v += kKnobHeight / 2.0;	knobStart.h -= kKnobHeight / 2.0;	knobStart.v -= kKnobHeight / 2.0;		// Get enclosing Rect	CDrawUtils::CalcEnclosingRect(knobStart,knobEnd,knob);		// paint	// BUNNY	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	(IsTarget()) ? ::RGBForeColor(&kBlackRGB) :  ::RGBForeColor(&kGreyRGB);//	::RGBForeColor(&kBlackRGB);	::FrameRect(&knob);	::PaintRect(&knob);}/* DrawSelf * -----------------   Generic drawself for all subclasses */void CShape::DrawSelf() {	Boolean isVis;	CDocumentApp *app = (CDocumentApp *) GetTopCommander();		isVisible(isVis);	if (isVis || !(app->inPlay())) {		Rect shapeRect = ShapeRect();		CResStore* rS;		PicHandle picture = NULL;		Handle temp = NULL;		Str255 picName = "\p";		DM* dM = ((CDocumentApp*) LCommander::GetTopCommander())->GetData();			sInfo->getPict(picName);		if (!::EqualString(picName, kDefaultMenuItemPtr, false, false)) {				rS = dM->getPictResStore(picName);			if (rS) rS->getHandle(temp);			picture = (PicHandle) temp;				}						::RGBForeColor(&Color_White);		::InsetRect(&shapeRect,1,1);			if (picture != NULL && isVis) ::DrawPicture(picture, &shapeRect);		CDocumentApp *app = (CDocumentApp *) GetTopCommander();		if (IsTarget() ||			app->GetCPalettePtr()->getTargetShape() == this) {			DrawResizeKnobs();		}		::RGBForeColor(&Color_Black);		if (! app->inPlay()) {				::FrameRect(&shapeRect);		}						if (highlighted) {			::FrameRect(&shapeRect);			for (int i = 0; i < 3; i++) {				::InsetRect(&shapeRect, 1, 1);				FrameRect(&shapeRect);			}			 for (int i = 0; i < 3; i++) {				::InsetRect(&shapeRect, -1, -1);			}		}				Boolean move;		isMoveable(move);				if (!app->inPlay() && !move) {			Rect l;			l = ShapeRect();			int j, k;			j = ((l.right - l.left) - 20) / 2;			k = ((l.bottom - l.top) - 27) / 2;			::InsetRect(&l, j, k);			Handle lockPict = ::GetResource('PICT', 144);			if (lockPict) {								Rect picFrame = (**((PicHandle)lockPict)).picFrame;				if (picFrame.right - picFrame.left < shapeRect.right - shapeRect.left					&& picFrame.bottom - picFrame.top < shapeRect.bottom - shapeRect.top) {					DrawPicture((PicHandle)lockPict, &l);				}				::ReleaseResource(lockPict);			}		}	}}/* DrawMyShape * -----------------   Let subclasses override this one */void CShape::DrawMyShape() {//nothing is really done.  in fact, this is never called.  hmmm./*	CResStore* rS;	PicHandle picture = NULL;	Handle temp = NULL;	Str255 picName = "\p";	DM* dM = ((CDocumentApp*) LCommander::GetTopCommander())->GetData();\			sInfo->getPict(picName);	if (picName != kDefaultMenuItemPtr) {			rS = dM->getResStore(picName);		rS->getHandle(temp);		picture = (PicHandle) temp;		}		Rect shapeRect = ShapeRect();	::RGBForeColor(&frameC);	::FrameRect(&shapeRect);	::RGBForeColor(&fillC);	::InsetRect(&shapeRect,1,1);	if (picture != NULL) ::DrawPicture(picture, &shapeRect);*/}/* BeTarget,DontBeTarget * -----------------   Always refresh when you're changing the target status */void CShape::BeTarget() {	// BUNNY	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	app->GetCPalettePtr()->setTargetShape(this);		Refresh();}void CShape::DontBeTarget() {	Refresh();}/* Resize * -----------------   Resize the object. Uses a helper function. */bool CShape::Resize(const SMouseDownEvent &inMouseDown, int whichKnob, bool isUndoable) {	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);	//CShapeAction *action = new CShapeAction(this,kResizeID,true, canvas);	bool shifted = ShapeShifter(inMouseDown,true,whichKnob);	canvas->SetDirty(true);/*	if (shifted && isUndoable) {		//action->PostMyself();	} else {		//delete action;		// Must have been a creation		if (shifted && ! isUndoable) {			//CShapeAction *action = new CShapeAction(this,kCreateID,true, canvas);			//action->PostMyself();			canvas->SetDirty(true);		}			}*/	return shifted;}/* Move * -----------------   Move the shape. Uses helper function. */bool CShape::Move(const SMouseDownEvent &inMouseDown) {	if (pos == NULL) pos = CDocumentApp::FindPaneInMyWindow(this,151);	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);	//CShapeAction *action = new CShapeAction(this,kMoveID,true, canvas);	bool shifted = false;	Boolean moveable;	sInfo->getMoveable(moveable);	if (moveable || !((CDocumentApp*) GetTopCommander())->inPlay()) {		shifted = ShapeShifter(inMouseDown,false);	}		if (shifted) {		//action->PostMyself();		canvas->SetDirty(true);	} else {		//delete action;	}		return shifted;}/******** POINT SETTING AND SHAPE MOVING SECTION **********//* SetStartEnd * -----------------   Sets the start and endpoint, and resizes the shape accordingly */void CShape::SetStartEnd(Point newStart, Point newEnd, bool considerKnob) {		// some simple vertical coordinate transformations if its in possession window	if (posessed) {		newStart.v -= kCanvasHP;		newEnd.v -= kCanvasHP;	}	Rect setRect,newRect,curRect;	Point curStart,curEnd;	sInfo->getStart(curStart);	sInfo->getEnd(curEnd);				CDrawUtils::CalcEnclosingRect(curStart,curEnd,curRect);	CDrawUtils::CalcEnclosingRect(newStart,newEnd,newRect);	CDrawUtils::CalcEnclosingRect(newStart,newEnd,setRect);	// do boundary checking here		if (newRect.left < 0) {		 setRect.left = 0;		 if (! considerKnob) setRect.right = curRect.right - curRect.left;	}		if (newRect.right > kCanvasW) {		 setRect.right = kCanvasW;		 if (! considerKnob) setRect.left = kCanvasW - (curRect.right - curRect.left);	}			if (newRect.top < 0) {		setRect.top = 0;		if (! considerKnob) setRect.bottom = curRect.bottom - curRect.top;	}		// different frame heights depending on if possessed or not	int height = ((posessed) ? kPosH : kWindowHE);	if (newRect.bottom > height) {		setRect.bottom = height;		if (! considerKnob) setRect.top = height - (curRect.bottom - curRect.top);	}	// Given a rect, orients start & end points && retains which point was where	OrientPointsFromRect(setRect,newStart,newEnd);	sInfo->setStart(newStart);	sInfo->setEnd(newEnd);		// get rect for exterior frame	Rect frame = ShapeFrameRect();	PlaceInSuperFrameAt(frame.left,frame.top,true);	ResizeFrameTo(frame.right - frame.left,				frame.bottom - frame.top,true);	}// for moving shape between possessions window and regular windowvoid CShape::SetMoveBetweenPWin(bool toPWin, Point &a, Point &b,Point &curPoint) {	if (toPWin) {		Rect curRect;		Point curStart,curEnd;				sInfo->getStart(curStart);		sInfo->getEnd(curEnd);		CDrawUtils::CalcEnclosingRect(curStart,curEnd,curRect);		oldWidth = curRect.right - curRect.left;		oldHeight = curRect.bottom - curRect.top;		// I'm drawing this rect outside the canvas so that 		// EnsureShapeWithinMouse will center points a and b		// around curPoint with dimensions rectToCenter				Rect rectToCenter;		rectToCenter.top = -50;		rectToCenter.bottom = 0;		rectToCenter.left = -50;		rectToCenter.right = 0;				EnsureShapeWithinMouse(curPoint,a,b,rectToCenter);				// do some setting for the DM -- trust me, this is necessary		sInfo->setStart(a);		sInfo->setEnd(b);			} else {		// same thing, this time a restoration to what it was before		Rect rectToCenter;		rectToCenter.top = -oldHeight;		rectToCenter.bottom = 0;		rectToCenter.left = -oldWidth;		rectToCenter.right = 0;				EnsureShapeWithinMouse(curPoint,a,b,rectToCenter);		sInfo->setStart(a);		sInfo->setEnd(b);	}}// makes sure that the mouse is pointing inside the shape. If not, then adjusts the shape// to be centered around the point. The mouse point is cp. newStart & newEnd are the points// to be modified if such a change needs to occur.bool CShape::EnsureShapeWithinMouse(Point cp, Point& newStart, Point& newEnd, Rect r) {	Point s, e;	sInfo->getStart(s);	sInfo->getEnd(e);		// if the rect is not within Point cp, then we'll have to recenter the rect	// and adjust the points accordingly	if (! (Within(r.right,r.left,cp.h) && Within(r.top,r.bottom,cp.v))) {		CenterRect(r,cp);		OrientPointsFromRect(r,s,e);		newStart.h = s.h;		newStart.v = s.v;		newEnd.h = e.h;		newEnd.v = e.v;				return true; // I did make changes	}		return false;}// centers rect around a pointvoid CShape::CenterRect(Rect& ret, Point p) {	int width,height;	width = (ret.right - ret.left);	height = (ret.bottom - ret.top);		ret.left = p.h - (width / 2);	ret.right = ret.left + width;		ret.top = p.v - (height/2);	ret.bottom = ret.top + height;}// determines if target is between a and b numericallybool CShape::Within(int a, int b, int target) {	if (a > b) return (target >= b && target <= a);	if (a < b) return (target >= a && target <= b);	if (a == b) return (target == a);	return false;}// handles setting the start and end point to the rect by taking// their old values & using that to determin where on the rect// the points refer.void CShape::OrientPointsFromRect(Rect r, Point& s, Point& e) {		if (s.h < e.h) {			s.h = r.left;			e.h = r.right;		} else {			e.h = r.left;			s.h = r.right;		}		if (s.v < e.v) {			s.v = r.top;			e.v = r.bottom;		} else {			e.v = r.top;			s.v = r.bottom;		}	}/* ShapeShifter * -----------------   "Shifts" the shape around the screen, either resizing or moving around   the screen. */bool CShape::ShapeShifter(const SMouseDownEvent &inMouseDown, bool considerKnob, int whichKnob) {	Point current, previous, newStart, newEnd;	bool resized;	int dh,dv, oH, oV;	bool p, oP;	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);	LWindow *wind = (LWindow *)CDocumentApp::FindPaneInMyWindow(this,kCanvasWindow);	Rect windowBounds;	wind->GetGlobalBounds(windowBounds);	// Initialize the vars	dh = dv = 0;	current = inMouseDown.wherePort; 	resized = false;		sInfo->getStart(newStart);	oH = newStart.h; oV = newStart.v;	sInfo->getEnd(newEnd);	SwitchTarget(GetTopCommander());	::GetMouse(&current);	oP = posessed;	while (::StillDown()) {		previous = current;		wind->FocusDraw();		::GetMouse(&current);				 dh = current.h - previous.h;		 dv = current.v - previous.v;				 		// If mouse has changed at all		if (dh != 0 || dv != 0) {			/* in this part, we ensure that the mouse is within the shape if 				you're doing a move */							Point s,e;			sInfo->getStart(s);			sInfo->getEnd(e);			Rect r;			CDrawUtils::CalcEnclosingRect(s, e, r);			// EnsureShapeWithinMouse returns true if we had to do a recentering			if (! considerKnob && EnsureShapeWithinMouse(current,newStart,newEnd,r)) { 				previous = current;				dh = 0;				dv = 0;							}						// Are we playing now??			if (app->inPlay()) {								// tell if possessed				p = ((CPosessions*) pos)->isInPosessions(current);				if (p) {									if (!posessed) { // it's in the possessions window but not possessed						Hide();						((CPosessions*)pos)->addItem(this);						SetSuperCommander((CPosessions*) pos);						canvas->RemoveShape(this, false);						posessed = true;//these will probably go through the dB.											SetMoveBetweenPWin(true,newStart,newEnd,current); // does the move btwn windows						Show();				//That's something to look at.											}									} else {					// not in possessions wind, but thinks it's possessed					if (posessed) {						Hide();						SetMoveBetweenPWin(false,newStart,newEnd,current);						canvas->AddShape(this);						SetSuperCommander((CCanvas*) ((CDocumentApp*) LCommander::GetTopCommander())->getCanvas());						((CPosessions*)pos)->removeItem(this);						Show();						posessed = false;					}					}							}				if (considerKnob && whichKnob == kknobEnd) {				if (newEnd.h + dh != current.h) {				dh = current.h - newEnd.h;				}				if (newEnd.v + dv != current.v) {				dv = current.v - newEnd.v;				}			}			if (considerKnob && whichKnob == kknobStart) {				if (newStart.h + dh != current.h) {				dh = current.h - newStart.h;				}				if (newStart.v + dv != current.v) {				dv = current.v - newStart.v;				}			}			// If we're not looking at knobs, or we are and its the 			// correct knob, then change the point			if (! considerKnob || whichKnob == kknobEnd) {				newEnd.h += dh;				newEnd.v += dv;			}						if (! considerKnob ||				whichKnob == kknobStart) {				newStart.h += dh;				newStart.v += dv;			}												SetStartEnd(newStart,newEnd,considerKnob);						Refresh();			UpdatePort();			resized = true;			isMoving = true;			canvas->updatePlace(current, this);			// BUNNY						app->GetCPalettePtr()->setTargetShape(this);		}	}		if (posessed) ((CPosessions*)pos)->UnHilite();	//canvas->Refresh();	int id = mPaneID;	canvas->SetDirty(resized); // only set's dirty if resized/moved. How nice	SwitchTarget(this);	isMoving = false;	return resized;}void CShape::DoDropTest(bool originallyPossessed, int origH, int origV) {	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);	Point current;	::GetMouse(&current);		if (app->inPlay()) {		if (!canvas->drop(current, this)) {			if (originallyPossessed) {				Hide();				((CPosessions*)pos)->addItem(this);				SetSuperCommander((CPosessions*) pos);				canvas->RemoveShape(this, false);				posessed = true;//these will probably go through the dB.				Show();				MoveBack(origH, origV + 300, true);			} else {				MoveBack(origH, origV, false);			}		}	}}void CShape::MoveBack(int oH, int oV, bool t) {	Point newStart, oldStart, newEnd, oldEnd;	sInfo->getStart(oldStart);	sInfo->getEnd(oldEnd);	newStart.h = oH;	newStart.v = oV;	newEnd.h = oldEnd.h - oldStart.h + newStart.h;	newEnd.v = oldEnd.v - oldStart.v + newStart.v;	if (t) {		if (newEnd.h < newStart.h) {			newEnd.h = newStart.h - 50;		} else {			newEnd.h = newStart.h + 50;		}		if (newEnd.v < newStart.v) {			newEnd.v = newStart.v - 50;		} else {			newEnd.v = newStart.v + 50;		}	}	SetStartEnd(newStart, newEnd);}/* ObeyCommand * -----------------   Simple override of ObeyCommand to deal with the clear menu command. */Boolean CShape::ObeyCommand(	PP_PowerPlant::CommandT	inCommand,	void					*ioParam){	//CShapeAction *action;	Boolean		cmdHandled = true;	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);		switch (inCommand) {		case cmd_Clear:			// Make an undoer action			//action = new CShapeAction(this,kDeleteID,true, canvas);			//action->PostMyself();			canvas->SetDirty(true);			DeleteMyself();			break;		default:			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}/* HandleKeyPress * -----------------   Handle when the delete key is pressed */Boolean CShape::HandleKeyPress(	const EventRecord	&inKeyEvent){	bool keyHandled = true;	Char16 theKey = inKeyEvent.message;	if ((theKey & charCodeMask) == char_Backspace) {		// Make an undoer action		CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);		//CShapeAction *action = new CShapeAction(this,kDeleteID,true, canvas);		//action->PostMyself();		DeleteMyself();	} else {		keyHandled = LCommander::HandleKeyPress(inKeyEvent);	}	return keyHandled;}/* FindCommandStatus * -----------------   Be sure to enable the clear menu command */void CShape::FindCommandStatus(	PP_PowerPlant::CommandT	inCommand,	Boolean					&outEnabled,	Boolean					&outUsesMark,	PP_PowerPlant::Char16	&outMark,	Str255					outName){	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	switch (inCommand) {			// Return menu item status according to command messages.		case PP_PowerPlant::cmd_Clear:			outEnabled = ! app->inPlay();			break;	/*	case kSetFrameColor:		case kSetFillColor:			outEnabled = true;			break;*/		default:			LCommander::FindCommandStatus(inCommand, outEnabled,												outUsesMark, outMark, outName);			break;	}}/* ClickSelf * -----------------   Deal with clicks on the object */void CShape::ClickSelf(const SMouseDownEvent &inMouseDown) {	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	SMouseDownEvent lastMD = inMouseDown;	Boolean moveable;	sInfo->getMoveable(moveable);	Boolean visible;	sInfo->getVisible(visible);	// Get a pointer to the canvas and the tool id	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);	canvas->swapMeUp(this);	int tool = ((CDocumentApp *)GetTopCommander())->GetPalettePtr()->GetToolID();	if (app->inPlay()) tool = kArrow;		// Only care about arrow tool.	if (tool == kArrow) {		SwitchTarget(this);		// If it's on either knob, resize; else if it's on shape, move; else, let		// canvas deal with click.				if (!app->inPlay() || (app->inPlay() && visible)) {					if (IsClickOnKnob(kknobStart,inMouseDown.whereLocal)) {				if (!app->inPlay()) Resize(inMouseDown, kknobStart, true);				return;			} else if (IsClickOnKnob(kknobEnd,inMouseDown.whereLocal)) {				if (!app->inPlay()) Resize(inMouseDown, kknobEnd, true);				return;			} else if (IsClickOnObject(inMouseDown.whereLocal)) {				if (app->inPlay() && moveable) UCursor::SetTheCursor(kClosedHandID);				bool origPossessed = posessed;				Point originalPoint;				sInfo->getStart(originalPoint);				if (!Move(inMouseDown)) {					if (app->inPlay()) RunClickScript();				} else {					DoDropTest(origPossessed,originalPoint.h,originalPoint.v);				}								if (app->inPlay() && moveable) UCursor::SetTheCursor(kOpenHandID);				return;			}		}	}	// Didn't like any of the other options, so send canvas click message.	Disable();	canvas->Click(lastMD);	Enable();	}/* DeleteMyself * -----------------   Delete's this object. */void CShape::DeleteMyself() {	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);	Hide(); // quick way to change command hierarchy & refresh	canvas->RemoveShape(this);//remove it from the data model.	delete this;		CDocumentApp *app = (CDocumentApp *) GetTopCommander();	//app->getCatalog()->UpdateShapes();	}/* IsClickOnKnob,IsClickOnObject * -----------------   Tells if the click is on a given knob or object   Uses the Mac Toolbox region handles */bool CShape::IsClickOnKnob(int whichKnob, Point point) {	RgnHandle knobRgn = ::NewRgn();	::OpenRgn();	(whichKnob == kknobStart) ? DrawResizeKnobStart() :	DrawResizeKnobEnd();	::CloseRgn(knobRgn);	Boolean inShape = ::PtInRgn(point,knobRgn);	::DisposeRgn(knobRgn);	return inShape;	}bool CShape::IsClickOnObject(Point point) {/*	RgnHandle knobRgn = ::NewRgn();	::OpenRgn();	DrawSelf();	::CloseRgn(knobRgn);	Boolean inShape = ::PtInRgn(point,knobRgn);	::DisposeRgn(knobRgn);*/	Point start,end;	sInfo->getStart(start);	sInfo->getEnd(end);	return (Within(start.h,end.h,point.h) && Within(start.v,end.v,point.v));//	return inShape;	}#pragma mark -#pragma mark === Unused functions/* SetFrameColor * -----------------   Sets the frame color */void CShape::SetFrameColor() {/*	RGBColor newColor;	if (GetNewColor(frameC,newColor)) {		frameC = newColor;		Refresh();	}*/}/* SetFillColor * -----------------   Sets the fill color */void CShape::SetFillColor() {/*	RGBColor newColor;	if (GetNewColor(fillC,newColor)) {		fillC = newColor;		Refresh();	}*/}/* GetNewColor * -----------------   Helper function to get a new color by prompting the user with an   LGA color selector thing. I copied this code from the LGAColorSelector */bool CShape::GetNewColor(RGBColor& inColor, RGBColor& outColor) {/*		Str255		prompt;		GetDescriptor ( prompt );		UDesktop::Deactivate ();		bool changed = ::GetColor ( Point_00, prompt, &inColor, &outColor);		UDesktop::Activate ();		return changed;*/return false;}#pragma mark -#pragma mark === Save & Undo Stuff/* GetInfo * -----------------   Gets shape info & returns in struct */void CShape::GetInfo(SShapeInfo& info) const {	sInfo->getStart(info.start);	sInfo->getEnd(info.end );		info.frameC = frameC;	info.fillC = fillC;}/* OrientFromInfo * -----------------   Adjusts shape provided info struct */void CShape::OrientFromInfo(const SShapeInfo info) {	SetStartEnd(info.start,info.end);		frameC = info.frameC;	fillC = info.fillC;	SwitchTarget(this);		Refresh();}/* WriteToStream * -----------------   Writes a shape to an LStream */void CShape::WriteToStream(LStream* inStream) {/*	SShapeInfo info;	GetInfo(info);	inStream->WriteData(&info,sizeof(info));*/}/* OrientFromStream * -----------------   Adjusts shape provided info struct-sized stream */void CShape::OrientFromStream(LStream* inStream) {/*	SShapeInfo info;	inStream->ReadData(&info,sizeof(info));	OrientFromInfo(info);*/}#pragma mark -#pragma mark === Bunny Methods//BUNNY CONSTRUCTORCShape::CShape(CShapeStore* info, CShapeInfo shapeInfo) {	sInfo = info;	fillC = shapeInfo.fillC;	frameC = shapeInfo.frameC;	InitPane(shapeInfo.paneInfo);	pos =  GetSuperView()->GetSuperView()->FindPaneByID(151);//ugh.	posessed = false;	}// BUNNY METHODSvoid CShape::getPicHandle(PicHandle &picture) {	CResStore* rS;	Handle temp;	Str255 picName;	DM* dM = ((CDocumentApp*) LCommander::GetTopCommander())->GetData();		sInfo->getPict(picName);	rS = dM->getPictResStore(picName);	if (rS) {		rS->getHandle(temp);		picture = (PicHandle) temp;	} else {		picture = NULL;	}}void CShape::setPict(StringPtr newPic) {	((CDocumentApp*) LCommander::GetTopCommander())->SetDirty(true);	sInfo->setPict(newPic);	Refresh();}void CShape::getName(StringPtr name) {	sInfo->getName(name);}void CShape::getPageT(Int32& outPageNum) {	return sInfo->getPage(outPageNum);}void CShape::getStart(Point& pt) {	sInfo->getStart(pt);}void CShape::getEnd(Point& pt) {	sInfo->getEnd(pt);}void CShape::isMoveable(Boolean& isMoveable) {	sInfo->getMoveable(isMoveable);}//more playmodeski changes! EG 3/7void CShape::isVisible(Boolean& isVis) {	/*if (((CDocumentApp*) LCommander::GetTopCommander())->inPlay()) {		sInfo->getVisible(isVis);	} else {		isVis = visible;	}*///And even moreski changes! AJ 3/8	sInfo->getVisible(isVis);}void CShape::getScript(StringPtr script) {	sInfo->getScript(script);}void CShape::getPict(StringPtr pict) {	sInfo->getPict(pict);}void CShape::setStart(Point value) {	sInfo->setStart(value);}void CShape::setEnd(Point value) {	sInfo->setEnd(value);}void CShape::setPictT(StringPtr name) {	sInfo->setPict(name);}void CShape::setMoveable(bool moveable) {	sInfo->setMoveable(moveable);	Refresh();}void CShape::setScript(StringPtr script) {	sInfo->setScript(script);}void CShape::setPage(ResID id) {	sInfo->setPage(id);}void CShape::setVisible(bool isVisible) {	sInfo->setVisible(isVisible);	Refresh(); // have to refresh if changing visible state}//is this ever used?  as it is now, it don't do nuttin.void CShape::MovePane(bool toPos) {	if (toPos) {	//something	} else {	//something else;	}}void CShape::setName(StringPtr name) {	((CDocumentApp*) LCommander::GetTopCommander())->SetDirty(true);	sInfo->setName(name);}Point CShape::centerAroundCursor (Point cursPos) {	Point newStart;	Point s, e;	sInfo->getStart(s);	sInfo->getEnd(e);	int heighth, breadth;	Rect r;	CDrawUtils::CalcEnclosingRect(s, e, r);	breadth = (r.right - r.left);	heighth = (r.bottom - r.top);		if (e.v > s.v) {		newStart.h = cursPos.h;// - (heighth / 2);	} else {		newStart.h = cursPos.h;// + (heighth / 2);	}	if (e.h > s.h) {		newStart.v = cursPos.v;// - (breadth / 2);	} else {		newStart.v = cursPos.v;// + (breadth / 2);	}	return newStart;}void CShape::onOver(Point cursPoint, CShape* dShape) {	Point s, e;	sInfo->getStart(s);	sInfo->getEnd(e);	Rect r;	if (isMoving || !((CDocumentApp*) LCommander::GetTopCommander())->inPlay()) {//		Refresh();//		UpdatePort();		return;	}	CDrawUtils::CalcEnclosingRect(s, e, r);	if (cursPoint.h < r.right && cursPoint.h > r.left && cursPoint.v < r.bottom && cursPoint.v > r.top) {			Str255 dShapeN,script;		this->getScript(script);		TArray<CScriptAction*>actions;		dShape->getName(dShapeN);		CScriptParser *sp = new CScriptParser(script);		highlighted = sp->hasDrop(dShapeN, actions);		delete sp;		Refresh();		//UpdatePort();	} else if (highlighted == true) {		highlighted = false;		Refresh();		//UpdatePort();	}}bool CShape::onDrop(Point cursPoint, CShape* dShape) {Str255 name, dName;	Point s, e;	sInfo->getStart(s);	sInfo->getEnd(e);	Rect r;	bool success = false;	if (!((CDocumentApp*) LCommander::GetTopCommander())->inPlay()) {		Refresh();		return false;			}	sInfo->getName(name);	dShape->getName(dName);	if (::EqualString(name, dName, false, false)) {		Refresh();		return true;			}	CDrawUtils::CalcEnclosingRect(s, e, r);	if (cursPoint.h < r.right && cursPoint.h > r.left && cursPoint.v < r.bottom && cursPoint.v > r.top) {		success = RunDropScript(dShape);	} else {		success = true;	}	highlighted = false;	Refresh();		return success;}void CShape::Sing(StringPtr name) {	Handle snd;	CResStore* sndStore;		DM* dM = ((CDocumentApp *) GetTopCommander())->GetData();	sndStore = dM->getSoundResStore(name);	sndStore->getHandle(snd);	::SndPlay(mSoundChannel, (SndListHandle)snd, true);}void CShape::Beep() {	::SysBeep(1);}void CShape::RunClickScript() {	TArray<CScriptAction *>actions;	Str255 script;	getScript(script);	CScriptParser *sp = new CScriptParser(script);		if (sp->hasClick(actions)) {		RunScript(actions);	}		delete sp;}bool CShape::RunDropScript(CShape* dShape) {	TArray<CScriptAction *>actions;	Str255 script;	getScript(script);	CScriptParser *sp = new CScriptParser(script);	Str255 shape, dShapeN, thisName;	bool success;		dShape->getName(dShapeN);	success = sp->hasDrop(dShapeN, actions);	if (success) {//		sInfo->getName(thisName);		RunScript(actions);	}		delete sp;	return success;}void CShape::RunEnterScript() {	TArray<CScriptAction *>actions;	Str255 script;	getScript(script);	CScriptParser *sp = new CScriptParser(script);			if (sp->hasEnter(actions)) {		RunScript(actions);	}		delete sp;}void CShape::RunScript(TArray<CScriptAction *>actions) {	TArrayIterator<CScriptAction *> iterator(actions);	// starts at index 1 by default	CScriptAction *action;	CDocumentApp* app = (CDocumentApp *) GetTopCommander();	DM* dM = app->GetData(); 	CShapeStore* acOb;	int page;		while (iterator.Next(action) != NULL) {	// Copies into the lvalue -- type is correct (int)		Str255 type;					if (action->isGoto(type)) {			if (CScriptParser::IsNumber(type)) {				app->JumpToPage(CScriptParser::StringToNumber(type));			} else {				app->JumpToPage	(type);				}		} else if (action->isPlay(type)) {			Sing(type);		} else if (action->isHide(type)) {			acOb = dM->getShapeStore(type);			acOb->setVisible(false);			LWindow::FindWindowByID(kBunnyWindowID)->Refresh();		} else if (action->isShow(type)) {			acOb = dM->getShapeStore(type);			acOb->setVisible(true);			LWindow::FindWindowByID(kBunnyWindowID)->Refresh();		} else if (action->isBeep()) {			Beep();		}				}}bool CShape::isPossessed() { return posessed; }void CShape::getNewShapeName(StringPtr outname) {	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	DM* dM = app->GetData();	LStr255 name(kEmptyString);	Int32 num = dM->getTotalShapes() - 1; // don't count me!!!	CShapeStore* shape;	do {			num++;					name = kEmptyString;		name += kUntitledShapeString;		name += "\p ";		name += static_cast<SInt32>(num);				shape = dM->getShapeStore((StringPtr)name);	} while (shape != NULL);					LString::CopyPStr(name,outname);}void CShape::AdjustCursorSelf(Point inPortPt, const EventRecord& inMacEvent){	CDocumentApp* app = (CDocumentApp *)GetTopCommander();	int tool = kArrow;	 Boolean moveable, visible;	 sInfo->getVisible(visible);	 sInfo->getMoveable(moveable);		if (app->inPlay()) {		if (moveable && visible) UCursor::SetTheCursor(kOpenHandID);		else UCursor::SetArrow();	 	//UCursor::SetPlus();	} else {		tool = app->GetPalettePtr()->GetToolID();		if (tool != kArrow) {			UCursor::SetCross();		} else {			UCursor::SetArrow();		}	}}