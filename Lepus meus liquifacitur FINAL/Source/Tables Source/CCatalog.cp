// =================================================================================//	CCatalog.cp				©1995-1998 Metrowerks Inc. All rights reserved.// =================================================================================#include <LEditField.h>#include <LString.h>#include <LTableMonoGeometry.h>#include <LTableSingleSelector.h>#include <LTableArrayStorage.h>#include <LWindow.h>#include <PP_Messages.h>#include <UAttachments.h>#include <LNodeArrayTree.h>#include <UDrawingState.h>#include <UDrawingUtils.h>#include <UKeyFilters.h>#include <UModalDialogs.h>#include <UTextTraits.h>#include "TablesConstants.h"#include "CCatalog.h"//ejs#include "CResStore.h"#include "CResDraw.h"#include "CPageStore.h"#include "CDocumentApp.h"#include <TArray.h>#include <TArrayIterator.h>#include "CSoundButton.h"#include "UDragAndDropUtils.h"#include "LStream.h"// ---------------------------------------------------------------------------------//		¥ CreateBookmarksTableStream [static]// ---------------------------------------------------------------------------------CCatalog *CCatalog::CreateBookmarksTableStream(	LStream	*inStream ){	return new CCatalog( inStream );}// ---------------------------------------------------------------------------------//		¥ CCatalog(LStream*)// ---------------------------------------------------------------------------------CCatalog::CCatalog(	LStream	*inStream )	: LHierarchyTable( inStream ), LDragAndDrop( UQDGlobals::GetCurrentPort(), this ){	// These are items that could be read in from the stream,	// but for this sample we'll just use these constants.	const Int16		kCellHeight			= 18;	const Int16		kFirstIndent		= 20;	const Int16		kLevelIndent		= 18;	const ResIDT	kGroupTextTraits	= 137;	const ResIDT	kBookmarkTextTraits	= 138;	const ResIDT 	kGroupIconID		= 1001;	const ResIDT	kBookmarkIconID		= 1000;	// Initialize the table.	InitBookmarksTable( kCellHeight, kFirstIndent, kLevelIndent, 		kGroupTextTraits, kBookmarkTextTraits, kGroupIconID, kBookmarkIconID );}// ---------------------------------------------------------------------------------//		¥ ~CCatalog// ---------------------------------------------------------------------------------CCatalog::~CCatalog(){}// ---------------------------------------------------------------------------------//		¥ InitBookmarksTable// ---------------------------------------------------------------------------------voidCCatalog::InitBookmarksTable(	Int16	inCellHeight,	Int16	inFirstIndent,	Int16	inLevelIndent,	ResIDT	inGroupTextTraits,	ResIDT	inBookmarkTextTraits,	ResIDT	inGroupIconID,	ResIDT	inBookmarkIconID ){	// Setup indents, text traits, and icon ids.	mFirstIndent = inFirstIndent;	mLevelIndent = inLevelIndent;	mGroupTextTraits = inGroupTextTraits;	mBookmarkTextTraits = inBookmarkTextTraits;	mGroupIconID = inGroupIconID;	mBookmarkIconID = inBookmarkIconID;	// Create some default items.	picResGroup = STableItem(kPictGroupType,kPictureResourceGroupName);	soundResGroup = STableItem(kSoundGroupType,kSoundResourceGroupName);	pageGroup = STableItem(kPageGroupType,kPageResourceGroupName);	shapeGroup = STableItem(kShapeGroupType,kShapeResourceGroupName);		// Create the helpers for this LTableView.	// Being a hierarchy table, it automatically gets LNodeArrayTree.	mTableGeometry = new LTableMonoGeometry( this, mFrameSize.width, inCellHeight );	mTableSelector = new LTableSingleSelector( this );	mTableStorage = new LTableArrayStorage( this, sizeof(STableItem) );	// Insert a single column.	InsertCols( 1, 0, nil, nil, false );	// Add these guys into the table	//InsertSiblingRows( 1, 0, &shapeGroup,		//sizeof(STableItem), true, false );	InsertSiblingRows( 1, 0, &pageGroup,		sizeof(STableItem), true, false );	InsertSiblingRows( 1, 0, &soundResGroup,		sizeof(STableItem), true, false );	InsertSiblingRows( 1, 0, &picResGroup,		sizeof(STableItem), true, false );	AddAttachment( new LKeyScrollAttachment( this ) );}void CCatalog::FinishCreateSelf() {	UpdateWholeList();}// Tells all to updatevoid CCatalog::UpdateWholeList() {	UpdatePicts();	UpdateSounds();	UpdatePages();	//UpdateShapes();}// instructs each of the update methods not to add in// new stuff from the DM. useful when closing a filevoid CCatalog::ClearWholeList() {	UpdatePicts(true);	UpdateSounds(true);	UpdatePages(true);	//UpdateShapes(true);}// removes all of the elements of a given type from the catalog, starting// from their parent cell (the folder)void CCatalog::RemoveAllOfType(STableCell cell, DataIDT type) {	STableCell targetCell = cell;	UInt32 theDataSize = sizeof(STableItem);	// loop while still are cells	while (GetNextCell(targetCell)) {		STableItem itemdata;		GetCellData(targetCell,&itemdata,theDataSize);				// do type comparison		if (itemdata.mType == type) {			RemoveRows(1,targetCell.row,true);			targetCell = cell;		} else {			// not same anymore, so break			break;		}	}				}// These update methods are for updating the catalog table// Due to the ingenious design of tarrays, they cannot be// broken down into helper functions because TArrays cannot be genericvoid CCatalog::UpdatePicts(bool clear) {	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	STableCell pictResGroupCell;	FindCellData(pictResGroupCell,&picResGroup,sizeof(STableItem)); 	// get rid of all the entries of a given type	RemoveAllOfType(pictResGroupCell,kPictItemType);		// do you want to re-add stuff in from the DM??	if (! clear) {		TableIndexT row;		STableCell prev;		row = pictResGroupCell.row;		prev = pictResGroupCell;		// Loop thru list of picts		TArray<CResStore*>pictRes = app->GetData()->getPictList();		TArrayIterator<CResStore *> pictIterator(pictRes);	// starts at index 1 by default		CResStore *rec;		int i = 0;				while (pictIterator.Next(rec) != NULL) {						// get the name and insert it into the table			Str255 picName;			rec->getName(picName);			STableItem pic(kPictItemType,picName);			if (i == 0)	InsertChildRows(1,row + (i++),&pic,sizeof(STableItem),false,false);			else InsertSiblingRows(1,row + (i++),&pic,sizeof(STableItem),false,false);			// getnextcell will set the value of prev to be the newly inserted cell			// refresh drawing of new cell			GetNextCell(prev);			RefreshCell( prev );		}	}		Refresh();}// same as pictvoid CCatalog::UpdateSounds(bool clear) {	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	STableCell soundResGroupCell;	FindCellData(soundResGroupCell,&soundResGroup,sizeof(STableItem)); 	RemoveAllOfType(soundResGroupCell,kSoundItemType);	if (! clear) {		TArray<CResStore*>soundRes = app->GetData()->getSoundList();		TArrayIterator<CResStore *> soundIterator(soundRes);	// starts at index 1 by default		TableIndexT row;		STableCell prev;		row = soundResGroupCell.row;		prev = soundResGroupCell;		CResStore *rec;		int i = 0;				while (soundIterator.Next(rec) != NULL) {						Str255 soundName;			rec->getName(soundName);			STableItem sound(kSoundItemType,soundName);			if (i == 0) InsertChildRows(1,row + (i++),&sound,sizeof(STableItem),false,false);			else InsertSiblingRows(1,row + (i++),&sound,sizeof(STableItem),false,false);			GetNextCell(prev);			RefreshCell( prev );		}	}		Refresh();}// same as pictvoid CCatalog::UpdatePages(bool clear) {	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	STableCell pageGroupCell;	FindCellData(pageGroupCell,&pageGroup,sizeof(STableItem)); 	RemoveAllOfType(pageGroupCell,kPageItemType);	if (! clear) {		TArray<CPageStore*>pages = app->GetData()->getPageList();		TArrayIterator<CPageStore *> pageIterator(pages);	// starts at index 1 by default		TableIndexT row;		STableCell prev;		row = pageGroupCell.row;		prev = pageGroupCell;		CPageStore *pageRec;		int i = 0;				while (pageIterator.Next(pageRec) != NULL) {						Str255 pageName;			pageRec->getName(pageName);			STableItem page(kPageItemType,pageName);			if (i == 0) InsertChildRows(1,row + (i++),&page,sizeof(STableItem),false,false);			else InsertSiblingRows(1,row + (i++),&page,sizeof(STableItem),false,false);						GetNextCell(prev);			RefreshCell( prev );		}	}		Refresh();}// same as pictvoid CCatalog::UpdateShapes(bool clear) {	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	STableCell shapeGroupCell;	FindCellData(shapeGroupCell,&shapeGroup,sizeof(STableItem)); 	RemoveAllOfType(shapeGroupCell,kShapeItemType);	if (! clear) {		TArray<CShapeStore*>shapes = app->GetData()->getShapeList();		TArrayIterator<CShapeStore *> shapeIterator(shapes);	// starts at index 1 by default		TableIndexT row;		STableCell prev;		row = shapeGroupCell.row;		prev = shapeGroupCell;		CShapeStore *shapeRec;		int i = 0;				while (shapeIterator.Next(shapeRec) != NULL) {						Str255 shapeName;			shapeRec->getName(shapeName);			STableItem shape(kShapeItemType,shapeName);			if (i == 0) InsertChildRows(1,row + (i++),&shape,sizeof(STableItem),false,false);			else InsertSiblingRows(1,row + (i++),&shape,sizeof(STableItem),false,false);			GetNextCell(prev);			RefreshCell( prev );		}	}		Refresh();}// ---------------------------------------------------------------------------------//		¥ DrawCell// ---------------------------------------------------------------------------------voidCCatalog::DrawCell(	const STableCell	&inCell,	const Rect			&inLocalRect ){	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	// Get the wide open index for the row.	TableIndexT	theWideOpenIndex;	theWideOpenIndex = GetWideOpenIndex( inCell.row );	// Draw a white line at the top	::RGBForeColor(&Color_White);	::MoveTo(inLocalRect.left,inLocalRect.top);	::LineTo(inLocalRect.right,inLocalRect.top);	// Draw the cell drop flag.	DrawDropFlag( inCell, theWideOpenIndex );	// Get the cell data.	STableItem	theItem;	if ( GetItemFromCell( inCell, theItem ) ) {		// Get the nesting level.		Uint32	theNestingLevel;		theNestingLevel = mCollapsableTree->GetNestingLevel( theWideOpenIndex );				// Calculate the cell height.		Int32	theCellHeight = inLocalRect.bottom - inLocalRect.top;		// Calculate the icon rect. Uses some magic numbers, but		// I'm not going to mess w/ success		Rect	theIconRect;		theIconRect.left = inLocalRect.left +			mFirstIndent + theNestingLevel * mLevelIndent;		theIconRect.right = theIconRect.left + 16;		theIconRect.top = inLocalRect.top + (theCellHeight - 16) / 2;		theIconRect.bottom = theIconRect.top + 16;				// monsterous switch to get the correct icon		ResIDT iconRes;		switch(theItem.mType) {			case(kPictGroupType):				iconRes = kPictFolderIconID;			break;			case(kPictItemType):				iconRes = kPictItemIconID;			break;				case(kSoundGroupType):				iconRes = kSoundFolderIconID;			break;			case(kSoundItemType):				iconRes = kSoundItemIconID;			break;			case(kPageGroupType):				iconRes = kPageFolderIconID;			break;			case(kPageItemType):				iconRes = kPageItemIconID;			break;			case(kShapeGroupType):				iconRes = kShapeFolderIconID;			break;			case(kShapeItemType):				iconRes = kShapeItemIconID;			break;			default:				iconRes = kItemIconID;			break;				}				// Draw the icon.		::PlotIconID( &theIconRect, atNone, ttNone, iconRes );			// Save and setup the text traits.		StTextState	theTextState;				Str255 pageName;		app->getCurrentPageName(pageName);				if (theItem.mType == kPageItemType && ::EqualString(pageName,theItem.mName,false,false)) {			UTextTraits::SetPortTextTraits(mGroupTextTraits );		} else {			UTextTraits::SetPortTextTraits(mBookmarkTextTraits );		}				// Get the font info.		FontInfo	theFontInfo;		::GetFontInfo( &theFontInfo );		// Draw the item name. More magic numbers not worth messing with		::MoveTo( theIconRect.right + 4 + 2, inLocalRect.bottom -			(theCellHeight - theFontInfo.ascent + theFontInfo.descent) / 2 );		::DrawString( theItem.mName );		}}// ---------------------------------------------------------------------------------//		¥ HiliteCellActively// ---------------------------------------------------------------------------------voidCCatalog::HiliteCellActively(	const STableCell	&inCell,	Boolean				inHilite ){	HiliteCellDraw(inCell,(inHilite) ? Color_Black : kSystemGrey, 		(inHilite) ? Color_White : Color_Black);}// ---------------------------------------------------------------------------------//		¥ HiliteCellInactively// ---------------------------------------------------------------------------------voidCCatalog::HiliteCellInactively(	const STableCell	&inCell,	Boolean				inHilite ){	HiliteCellDraw(inCell,(inHilite) ? kGreyRGB : kSystemGrey, 		(inHilite) ? Color_White : Color_Black);}// Eric's own custom function for drawing hilited cells on a grey backgroundvoid CCatalog::HiliteCellDraw(const STableCell	&inCell, RGBColor bgColor,	RGBColor textColor) {	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	// Get the cell frame and focus the view.	Rect	theCellFrame,inLocalRect;	if ( GetLocalCellRect( inCell, theCellFrame ) && FocusExposed() ) {		inLocalRect = theCellFrame;		TableIndexT	theWideOpenIndex;		theWideOpenIndex = GetWideOpenIndex( inCell.row );		// Get the nesting level.		Uint32	theNestingLevel;		theNestingLevel = mCollapsableTree->GetNestingLevel( theWideOpenIndex );				// Adjust the frame to account for the drop flag area.		theCellFrame.left += (mFirstIndent + (theNestingLevel + 1) * mLevelIndent); // ejs		// draw bgcolor		::RGBForeColor(&bgColor);		::PaintRect(&theCellFrame);		// draw white lines above 		::RGBForeColor(&Color_White);		::MoveTo(inLocalRect.left,inLocalRect.top);		::LineTo(inLocalRect.right,inLocalRect.top);			STableItem	theItem;		if ( GetItemFromCell( inCell, theItem ) ) {			// Save and setup the text traits.			StTextState	theTextState;		Str255 pageName;		app->getCurrentPageName(pageName);		if (theItem.mType == kPageItemType && ::EqualString(pageName,theItem.mName,false,false)) {			UTextTraits::SetPortTextTraits(mGroupTextTraits );		} else {			UTextTraits::SetPortTextTraits(mBookmarkTextTraits );		}//			UTextTraits::SetPortTextTraits( (theItem.mType == kGroupItemType) ?//				mGroupTextTraits : mBookmarkTextTraits );						// Get the font info.			FontInfo	theFontInfo;			::GetFontInfo( &theFontInfo );			// Draw the item name.			::MoveTo( theCellFrame.left + 4, theCellFrame.bottom -				((theCellFrame.bottom - theCellFrame.top) - theFontInfo.ascent + theFontInfo.descent) / 2 );			// set color appropriately			::RGBForeColor(&textColor);			::DrawString( theItem.mName );		}		}}// ---------------------------------------------------------------------------------//		¥ ClickCell// ---------------------------------------------------------------------------------voidCCatalog::ClickCell(	const STableCell		&inCell,	const SMouseDownEvent	&inMouseDown ){#pragma unused( inMouseDown )	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	SwitchTarget(this); // ejs -- so can receive keyboard commands	// Check for double-click.	if ( GetClickCount() > 1 ) {		// Get the cell data (the bookmark item).		STableItem	theItem;		if ( GetItemFromCell( inCell, theItem )) {						if (theItem.mType == kPictItemType || 				theItem.mType == kSoundItemType) {				EditRes(theItem,theItem.mType);						} else if (theItem.mType == kPageItemType) {				app->JumpToPage(theItem.mName);				UpdatePages();			}											SelectCell(inCell);		}	// single click, so start drag & drop stuff	} else if ( DragAndDropIsPresent() &&		::WaitMouseMoved( inMouseDown.macEvent.where ) ) {		// Get the selected cell.		STableCell	theCell;		theCell = GetFirstSelectedCell( );				if ( IsValidCell( theCell ) ) {					// Focus.			FocusDraw();						// Get the cell frame.			Rect	theCellFrame;			GetLocalCellRect( theCell, theCellFrame );				// Get the cell data			STableItem itemdata;			UInt32 theDataSize = sizeof(STableItem);			GetCellData(theCell,&itemdata,theDataSize);			// if it's a pict or a sound...			if (itemdata.mType == kPictItemType || 				itemdata.mType == kSoundItemType) {				// get it's store & handle				CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();				CResStore *store = (itemdata.mType == kPictItemType) ? 									(app->GetData()->getPictResStore(itemdata.mName)) :									(app->GetData()->getSoundResStore(itemdata.mName));				Handle ph;				store->getHandle(ph);																// Create the drag task.				LDragTask	theDragTask( inMouseDown.macEvent, theCellFrame,								1, (itemdata.mType == kPictItemType) ? 'PICT' : 'snd ', 								(Ptr)*ph, ::GetHandleSize((Handle) ph), 0 );						}						// Invalidate LView's focus cache.			// The port may have changed during the drag.			LView::OutOfFocus( nil );					}	}}// ---------------------------------------------------------------------------------//		¥ ResizeFrameBy// ---------------------------------------------------------------------------------voidCCatalog::ResizeFrameBy(	Int16		inWidthDelta,	Int16		inHeightDelta,	Boolean		inRefresh ){	// Call inherited for default behavior.	LHierarchyTable::ResizeFrameBy( inWidthDelta, inHeightDelta, inRefresh );		// Resize the single column to the full width of the table.	SetColWidth( mFrameSize.width, 1, 1 );	AdjustImageSize( inRefresh );}// ---------------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------------BooleanCCatalog::HandleKeyPress(	const EventRecord	&inKeyEvent ){	Boolean	isKeyHandled = true;	// Focus in case any drawing needs to be done.	FocusDraw();	Char16 theKey = inKeyEvent.message;		// DEBUG: int foo = (theKey & charCodeMask);		// DEBUG: int fee = char_LeftArrow;	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	if ( UKeyFilters::IsTEDeleteKey( inKeyEvent.message ) ) {			// Get the selected cell.		STableCell	theCell( 0, 1 );		if ( GetNextSelectedCell( theCell ) ) {					// Get the cell wide open index.			TableIndexT	theWideOpenIndex = GetWideOpenIndex( theCell.row );					// get the cell data			UInt32 theDataSize = sizeof(STableItem);			STableItem itemdata;			GetCellData(theCell,&itemdata,theDataSize);						switch(itemdata.mType) {				case (kPictItemType):					app->GetData()->removePictResStore(itemdata.mName);									app->GetCPalettePtr()->updatePopupValues(); // don't forget to update the popup!!					UpdatePicts();				break;				case (kSoundItemType) :					app->GetData()->removeSoundResStore(itemdata.mName);					UpdateSounds();				break;				case kPageItemType:					CPageStore *page = app->GetData()->getPageStore(itemdata.mName);					Int32 pageNum;					page->getPage(pageNum);					// ONLY CAN REMOVE SUBSEQUENT PAGES AFTER THE HOME PAGE!!					// CAN'T REMOVE START PAGE!!!!					if (pageNum != kStartPageNum) app->GetData()->removePageStore(pageNum);					app->JumpToPage(kStartPageNum);					//UpdateShapes();				break;			/*********************************************			SUZANNE MUST FIX THIS TO REMOVE A PAGE BY NAME						AJ MUST FIX THIS TO REMOVE A SHAPE				case (kPageItemType) :			//		app->GetData()->removePictResStore(itemdata.mName);											break;				case (kShapeItemType) :									break; 			**********************************************/				default: // trying to delete folder cell so return				return true;							}			// Delete the row.			//RemoveRows( 1, theWideOpenIndex, true );				}	} else if ((theKey & charCodeMask) == kReturnKeyID ||			(theKey & charCodeMask) == kEnterKeyID) {		// if you pressed return or enter then edit the item		STableCell inCell = GetFirstSelectedCell();		STableItem	theItem;		if ( GetItemFromCell( inCell, theItem )) {						if (theItem.mType == kPictItemType || 				theItem.mType == kSoundItemType) {				EditRes(theItem,theItem.mType);			} else if (theItem.mType == kPageItemType) {//				app->JumpToPage(theItem.mName);//				UpdatePages();				EditPage(theItem,theItem.mType);			}					SelectCell(inCell);		}				} else if ((theKey & charCodeMask) == char_UpArrow) {		STableCell inCell = GetFirstSelectedCell();		if (GetPreviousCell(inCell)) {			SelectCell(inCell);			ScrollCellIntoFrame(inCell);		}	} else if ((theKey & charCodeMask) == char_DownArrow) {		STableCell inCell = GetFirstSelectedCell();		if (GetNextCell(inCell)) {			SelectCell(inCell);			ScrollCellIntoFrame(inCell);		}	} else {		// Call inherited.		isKeyHandled = LCommander::HandleKeyPress( inKeyEvent );	}				return isKeyHandled;}// ---------------------------------------------------------------------------------//		¥ GetItemFromCell// ---------------------------------------------------------------------------------BooleanCCatalog::GetItemFromCell(	const STableCell	&inCell,	STableItem	&outItem ){	Boolean	isValid = false;	Uint32	theDataSize = sizeof(STableItem);	// Get the wide open index for the row.	TableIndexT	theWideOpenIndex;	theWideOpenIndex = GetWideOpenIndex( inCell.row );	// Create an STableCell object for the cell	STableCell	theWideOpenCell( theWideOpenIndex, 1 );	// Get the cell data (the bookmark item).	GetCellData( theWideOpenCell, &outItem, theDataSize );		if ( theDataSize == sizeof(STableItem) ) {			// The item must be valid.		isValid = true;		}	return isValid;}void CCatalog::EditRes(STableItem &ioItem, DataIDT type) {	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	CResStore *res = ((type == kPictItemType) ? app->GetData()->getPictResStore(ioItem.mName) :							app->GetData()->getSoundResStore(ioItem.mName));								bool success = ((type == kPictItemType) ? EditPictureDialog(ioItem) : EditSoundDialog(ioItem));	if (success) {		res->setName(ioItem.mName);		if (type == kPictItemType) {			UpdatePicts();			app->GetCPalettePtr()->updatePopupValues();		} else {			UpdateSounds();		}	}	SwitchTarget(this);}void CCatalog::EditPage(STableItem &ioItem, DataIDT type) {	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	CPageStore *res = app->GetData()->getPageStore(ioItem.mName);								bool success = EditPageDialog(ioItem);	if (success) {		res->setName(ioItem.mName);		UpdatePages();	}	SwitchTarget(this);}// ---------------------------------------------------------------------------------//		¥ EditTableItem// ---------------------------------------------------------------------------------Boolean CCatalog::EditPictureDialog(STableItem	&ioItem) {	Boolean	isChanged = false;	// Edit the item based on it's type.	if ( ioItem.mType == kPictItemType ) {		// Create the dialog handler.		StDialogHandler	theHandler( kEditCatalogPictureID, this );		// Get the dialog.		LWindow	*theDialog = theHandler.GetDialog();				// Setup the name edit field.		LEditField	*theNameEditField;		theNameEditField = dynamic_cast <LEditField *>			(theDialog->FindPaneByID( kPictureNameEditField ));		ThrowIfNil_ (theNameEditField);				theNameEditField->SetDescriptor( ioItem.mName );		theNameEditField->SelectAll();		theDialog->SetLatentSub( theNameEditField );				CResDraw *thePreviewPane;		thePreviewPane = dynamic_cast <CResDraw *>			(theDialog->FindPaneByID( kPicturePreviewPane ));		ThrowIfNil_ (thePreviewPane);		// Muck with setting the preview pane's picture handle		CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();		CResStore *res = app->GetData()->getPictResStore(ioItem.mName);		if (res) {			Handle h;			res->getHandle(h);			thePreviewPane->setHandle((PicHandle)h);		}						// Show the dialog.		theDialog->Show();		while ( true ) {			// Handle dialog events.			MessageT	theMessage = theHandler.DoDialog();						if ( theMessage == msg_Cancel ) {								// Break out of the loop.				break;							} else if ( theMessage == msg_OK ) {							// Get the new name and location.				theNameEditField->GetDescriptor( ioItem.mName );				isChanged = true;				// Break out of the loop.				break;						}				}	}		return isChanged;}Boolean CCatalog::EditSoundDialog(STableItem	&ioItem) {	Boolean	isChanged = false;	// Edit the item based on it's type.	if ( ioItem.mType == kSoundItemType ) {		// Create the dialog handler.		StDialogHandler	theHandler( kEditCatalogSoundID, this );		// Get the dialog.		LWindow	*theDialog = theHandler.GetDialog();				// Setup the name edit field.		LEditField	*theNameEditField;		theNameEditField = dynamic_cast <LEditField *>			(theDialog->FindPaneByID( kPictureNameEditField ));		ThrowIfNil_ (theNameEditField);				theNameEditField->SetDescriptor( ioItem.mName );		theNameEditField->SelectAll();		theDialog->SetLatentSub( theNameEditField );				CSoundButton *thePreviewPane;		thePreviewPane = dynamic_cast <CSoundButton *>			(theDialog->FindPaneByID( kSoundButtonID ));		ThrowIfNil_ (thePreviewPane);		// Muck with setting the preview pane's picture handle		CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();		CResStore *res = app->GetData()->getSoundResStore(ioItem.mName);		if (res) {			Handle h;			res->getHandle(h);			thePreviewPane->setHandle(h);		}						// Show the dialog.		theDialog->Show();		while ( true ) {			// Handle dialog events.			MessageT	theMessage = theHandler.DoDialog();						if ( theMessage == msg_Cancel ) {								// Break out of the loop.				break;							} else if ( theMessage == msg_OK ) {							// Get the new name and location.				theNameEditField->GetDescriptor( ioItem.mName );				isChanged = true;				// Break out of the loop.				break;						}				}	}		return isChanged;}Boolean CCatalog::EditPageDialog(STableItem	&ioItem) {	Boolean	isChanged = false;	// Edit the item based on it's type.	if ( ioItem.mType == kPageItemType ) {		// Create the dialog handler.		StDialogHandler	theHandler( kEditCatalogPageID, this );		// Get the dialog.		LWindow	*theDialog = theHandler.GetDialog();				// Setup the name edit field.		LEditField	*theNameEditField;		theNameEditField = dynamic_cast <LEditField *>			(theDialog->FindPaneByID( kPageNameEditField ));		ThrowIfNil_ (theNameEditField);				theNameEditField->SetDescriptor( ioItem.mName );		theNameEditField->SelectAll();		theDialog->SetLatentSub( theNameEditField );				LCaption *thePreviewPane;		thePreviewPane = dynamic_cast <LCaption *>			(theDialog->FindPaneByID( kPageNumCaptionID ));		ThrowIfNil_ (thePreviewPane);		// Muck with setting the preview pane's picture handle		CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();		CPageStore *res = app->GetData()->getPageStore(ioItem.mName);		if (res) {			Int32 num;			res->getPage(num);			thePreviewPane->SetValue(num);		}						// Show the dialog.		theDialog->Show();		while ( true ) {			// Handle dialog events.			MessageT	theMessage = theHandler.DoDialog();						if ( theMessage == msg_Cancel ) {								// Break out of the loop.				break;							} else if ( theMessage == msg_OK ) {							// Get the new name and location.				theNameEditField->GetDescriptor( ioItem.mName );				isChanged = true;				// Break out of the loop.				break;						}				}	}		return isChanged;}#pragma mark -#pragma mark =Drag & drop defns// only get picts & soundsBooleanCCatalog::ItemIsAcceptable(	DragReference	inDragRef,	ItemReference	inItemRef ){	// Make sure the table is enabled and	// there's text in the drag data.	FlavorFlags	theFlags;	return IsEnabled() && ((::GetFlavorFlags( inDragRef,		inItemRef, 'PICT', &theFlags ) == noErr) ||			(::GetFlavorFlags( inDragRef,				inItemRef, 'snd ', &theFlags ) == noErr));}voidCCatalog::ReceiveDragItem(	DragReference	inDragRef,	DragAttributes	inDragAttrs,	ItemReference	inItemRef,	Rect			&inItemBounds ){#pragma unused( inDragAttrs, inItemBounds )	// can only copy if you're holding the option key	if (UDragAndDropUtils::CheckIfViewIsAlsoSender( inDragRef )) {		if (!UDragAndDropUtils::CheckForOptionKey( inDragRef )) {			Refresh();			return;		}	}	FlavorFlags	theFlags;	OSErr pictErr;	OSErr sndErr;	OSErr shapeErr;	// if there's a pict or a sound	if ((pictErr = ::GetFlavorFlags( inDragRef, inItemRef, 'PICT', &theFlags )) == noErr ||		(sndErr = ::GetFlavorFlags( inDragRef, inItemRef, 'snd ', &theFlags )) == noErr) {							Size	theDataSize;		// Get the data size and set the string length.		ThrowIfOSErr_( ::GetFlavorDataSize( inDragRef,			inItemRef, (pictErr == noErr) ? 'PICT' : 'snd ', &theDataSize ) );		// make a handle		OSErr retCode;	    Handle tempHandle = ::TempNewHandle(theDataSize, &retCode);	    if (tempHandle == nil) {	          tempHandle = ::NewHandle(theDataSize);	    }		if (tempHandle != nil) {				// get the data	            HLock(tempHandle);	            retCode = ::GetFlavorData(inDragRef, inItemRef, (pictErr == noErr) ? 'PICT' : 'snd ',	             *tempHandle,&theDataSize, 0);				// if it got it, update DM & myself				if (retCode == noErr) {					CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();					app->AddResourceToDM((pictErr == noErr) ? 'PICT' : 'snd ',tempHandle);					Refresh();				}		}	} 	}// ---------------------------------------------------------------------------------//		¥ HiliteDropArea// ---------------------------------------------------------------------------------voidCCatalog::HiliteDropArea(	DragReference	inDragRef ){	// Get the frame rect.	Rect	theRect;	CalcLocalFrameRect( theRect );	// Show the drag hilite in the drop area.	RgnHandle	theRgnH = ::NewRgn();	::RectRgn( theRgnH, &theRect );	::ShowDragHilite( inDragRef, theRgnH, true );	::DisposeRgn( theRgnH );}// force a refresh of the table when it's done hilitingvoidCCatalog::UnhiliteDropArea(	DragReference	inDragRef){#pragma unused (inDragRef)	Refresh();}#pragma mark -// =================================================================================//	STableItem// =================================================================================// ---------------------------------------------------------------------------------//		¥ STableItem// ---------------------------------------------------------------------------------STableItem::STableItem(){	mType = 0;	mName[0] = 0;}// ---------------------------------------------------------------------------------//		¥ STableItem( DataIDT )// ---------------------------------------------------------------------------------STableItem::STableItem(	DataIDT	inType ){	mType = inType;	LString::CopyPStr( "\pUntitled", mName, sizeof(Str255) );}// ---------------------------------------------------------------------------------//		¥ STableItem( DataIDT, Str31, Str255 )// ---------------------------------------------------------------------------------STableItem::STableItem(	DataIDT	inType,	StringPtr	inName){	mType = inType;	LString::CopyPStr( inName, mName, sizeof(Str255) );}voidCCatalog::InsideDropArea(	DragReference	inDragRef ){	// Call inherited.	LDragAndDrop::InsideDropArea( inDragRef );	// Focus.	if ( FocusDraw() ) {		Rect r;		CalcLocalFrameRect(r);		::RGBForeColor(&Color_Black);		::FrameRect(&r);	}}/*void CCatalog::EditPicture(STableItem &ioItem) {	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	CResStore *res = app->GetData()->getPictResStore(ioItem.mName);	if (EditPictureDialog(ioItem)) {		res->setName(ioItem.mName);		app->GetCPalettePtr()->updatePopupValues();		UpdatePicts();	}	SwitchTarget(this);}void CCatalog::EditSound(STableItem &ioItem) {	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	CResStore *res = app->GetData()->getSoundResStore(ioItem.mName);	if (EditSoundDialog(ioItem)) {		res->setName(ioItem.mName);		UpdateSounds();	}	SwitchTarget(this);	}// ---------------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------------BooleanCCatalog::ObeyCommand(	CommandT	inCommand,	void		*ioParam ){	Boolean	cmdHandled = true;	switch ( inCommand ) {		case cmd_OpenBookmark:		{			// Find the selected cell and get the bookmark item.			// Make sure it's a bookmark, not a group.			STableCell			theCell( 0, 1 );			STableItem	theItem;			if ( GetNextSelectedCell( theCell ) &&				GetItemFromCell( theCell, theItem ) &&				theItem.mType == kBookmarkItemType ) {				// Open the bookmark.				OpenLocation( theItem );			}		}		break;		case cmd_InsertGroup:		{			// Insert a new group.			InsertNewItem(kGroupItemType);		}		break;		case cmd_InsertBookmark:		{			// Insert a new bookmark.			InsertNewItem(kBookmarkItemType);		}		break;		case cmd_EditBookmark:		{			// Find the selected cell and get the bookmark item.			STableCell			theCell( 0, 1 );			STableItem	theItem;			if ( GetNextSelectedCell( theCell ) &&				GetItemFromCell( theCell, theItem ) ) {				// Edit the item.				if ( EditTableItem( theItem ) ) {									// Get the cell wide open cell.					TableIndexT	theWideOpenIndex;					theWideOpenIndex = GetWideOpenIndex( theCell.row );					STableCell	theWideOpenCell( theWideOpenIndex, 1 );					// Set the new cell data.					SetCellData( theWideOpenCell,						&theItem, sizeof(STableItem) );										// Refresh the cell.					RefreshCell( theCell );								}			}		}		break;		default:		{			// Call inherited.			cmdHandled = LCommander::ObeyCommand( inCommand, ioParam );		}		break;	}	return cmdHandled;}// ---------------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------------voidCCatalog::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName ){	switch ( inCommand ) {/*		case cmd_Close:		{			outEnabled = false;		}		break;		default:		{			// Call inherited.			LCommander::FindCommandStatus( inCommand,				outEnabled, outUsesMark, outMark, outName );		}		break;	}}// ---------------------------------------------------------------------------------//		¥ InsertNewItem// ---------------------------------------------------------------------------------//	Insert a new group or bookmark. If an item is selected, it is a group item, //  and it is expanded, the new item appears as a child of the selected item.//  Otherwise it appears as a sibling, immediately after the selected item.//  If no item is selected, the new item appears at the beginning of the list.voidCCatalog::InsertNewItem(DataIDT inItemType){	TableIndexT	theWideOpenIndex;	STableItem	theItem;		// Create a new default item.	STableItem	theNewItem( inItemType );	// Groups are collapsable.	Boolean		collapsable = (inItemType == kGroupItemType);	// Start search for selected cell at beginning of table.	STableCell	theCell( 0, 0);		if (GetNextSelectedCell (theCell)){ // a selected cell					// Get data from selected cell, assume it's valid.		GetItemFromCell( theCell, theItem );		// Get the row wide open index.		theWideOpenIndex = GetWideOpenIndex( theCell.row );		// If selected row is a group and is open.		if ( theItem.mType == kGroupItemType &&			mCollapsableTree->IsExpanded( theWideOpenIndex ) ) {						InsertChildRows( 1, theWideOpenIndex, &theNewItem,						sizeof(STableItem), collapsable, true );				} else { // not a group or not open					// Create sibling right after this one.			InsertSiblingRows( 1, theWideOpenIndex, &theNewItem,					sizeof(STableItem), collapsable, true );					}		} else { // nothing selected				// We enter here with theCell at (0,0).		theCell.col = 1; // so we can select the new item as row 1 column 1						// Add a sibling row at start of list (after row zero).		InsertSiblingRows( 1, 0, &theNewItem,			sizeof(STableItem), collapsable, true );	}		// Unselect all cells and select the new cell.	UnselectAllCells();	theCell.row++;	if ( IsValidCell( theCell ) ) SelectCell( theCell );}BooleanCCatalog::EditTableItem(	STableItem	&ioItem ){	Boolean	isChanged = false;	// Edit the item based on it's type.	if ( ioItem.mType == kGroupItemType ) {			// Edit the group item.		isChanged = UModalDialogs::AskForOneString( this,			rPPob_EditGroupDialog, kGroupNameEditField, ioItem.mName );	} else if ( ioItem.mType == kBookmarkItemType ) {		// Create the dialog handler.		StDialogHandler	theHandler( rPPob_EditBookmarkDialog, this );		// Get the dialog.		LWindow	*theDialog = theHandler.GetDialog();				// Setup the name edit field.		LEditField	*theNameEditField;		theNameEditField = dynamic_cast <LEditField *>			(theDialog->FindPaneByID( kBookmarkNameEditField ));		ThrowIfNil_ (theNameEditField);				theNameEditField->SetDescriptor( ioItem.mName );		theNameEditField->SelectAll();		theDialog->SetLatentSub( theNameEditField );				// Setup the location edit field.		LEditField	*theLocationEditField;		theLocationEditField = dynamic_cast <LEditField *>			(theDialog->FindPaneByID( kBookmarkLocationEditField ));		ThrowIfNil_ (theLocationEditField);//		theLocationEditField->SetDescriptor( ioItem.mLocation );				// Show the dialog.		theDialog->Show();		while ( true ) {			// Handle dialog events.			MessageT	theMessage = theHandler.DoDialog();						if ( theMessage == msg_Cancel ) {								// Break out of the loop.				break;							} else if ( theMessage == msg_OK ) {							// Get the new name and location.				theNameEditField->GetDescriptor( ioItem.mName );//				theLocationEditField->GetDescriptor( ioItem.mLocation );				isChanged = true;				// Break out of the loop.				break;						}				}	}		return isChanged;}// ---------------------------------------------------------------------------------//		¥ SelectionChanged// ---------------------------------------------------------------------------------voidCCatalog::SelectionChanged(){	// Menu items depend on the current selection.	SetUpdateCommandStatus( true );}*/