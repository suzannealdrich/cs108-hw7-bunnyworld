#include "LEditText.h"class CNameEditText :public LEditText {public:	enum { class_ID = FOUR_CHAR_CODE('cnED') };	CNameEditText(LStream *inStream) : LEditText(inStream) {	}		void DontBeTarget() {		CPalette *pal = (CPalette *)CDocumentApp::FindPaneInMyWindow(this,kBunPal);		pal->setShapeName();		LEditText::DontBeTarget();	}	Boolean	HandleKeyPress(		const EventRecord	&inKeyEvent)	{		Boolean		keyHandled = true;		EKeyStatus	theKeyStatus = keyStatus_Input;		Char16		theChar = (Char16) (inKeyEvent.message & charCodeMask);		LCommander	*theTarget = GetTarget();				if (inKeyEvent.modifiers & cmdKey || theChar == kEnterKeyID || theChar == kReturnKeyID) {	// Always pass up when the command			theKeyStatus = keyStatus_PassUp;	//   key is down			LWindow *wind = LWindow::FindWindowByID(kBunnyWindowID);			if (wind) SwitchTarget(wind);			else SwitchTarget(LCommander::GetTopCommander());					} else if (mKeyFilter != nil) {			// Filter key stroke												// There should be a key filter.												// Editing keys and undo won't work												// without a proper key filter.			theKeyStatus = (*mKeyFilter)(mTextEditH, (Char16) inKeyEvent.message,											theChar, inKeyEvent.modifiers);		}				StFocusAndClipIfHidden	focus(this);		StCQDProcsState			qdProcs(false, nil,										(CGrafPtr) UQDGlobals::GetCurrentPort());														// Save whether current selection												//   is empty or not		bool	beforeSel = (**mTextEditH).selStart == (**mTextEditH).selEnd;				bool	textChanged = false;		bool	passUp = false;				switch (theKeyStatus) {					case keyStatus_Input: {				if (TooManyCharacters(1)) {					::SysBeep(1);					break;				}								qdProcs.SetProcs(mIsPassword, &sPasswordProcs);				if (mTypingAction == nil) {					mTypingAction = new LTETypingAction(mTextEditH, this, this);					PostAction(mTypingAction);				}				if (mTypingAction != nil) {					mTypingAction->InputCharacter((SInt16) theChar);				} else {					::TEKey((SInt16) theChar, mTextEditH);				}				textChanged = true;				break;			}							case keyStatus_TEDelete: {				if ((**mTextEditH).selEnd > 0) {					qdProcs.SetProcs(mIsPassword, &sPasswordProcs);					if (mTypingAction == nil) {						mTypingAction = new LTETypingAction(mTextEditH, this, this);						PostAction(mTypingAction);					}					if (mTypingAction != nil) {						mTypingAction->BackwardErase();					} else {						::TEKey(char_Backspace, mTextEditH);					}					textChanged = true;				}				break;			}							case keyStatus_TECursor: {				qdProcs.SetProcs(mIsPassword, &sPasswordProcs);				::TEKey((SInt16) theChar, mTextEditH);				break;			}							case keyStatus_ExtraEdit: {				switch (theChar) {										case char_Home:						qdProcs.SetProcs(mIsPassword, &sPasswordProcs);						::TESetSelect(0, 0, mTextEditH);						break;											case char_End:						qdProcs.SetProcs(mIsPassword, &sPasswordProcs);						::TESetSelect(max_Int16, max_Int16, mTextEditH);						break;											case char_FwdDelete:						if ((**mTextEditH).selStart < (**mTextEditH).teLength) {							qdProcs.SetProcs(mIsPassword, &sPasswordProcs);							if (mTypingAction == nil) {								mTypingAction = new LTETypingAction(mTextEditH, this, this);								PostAction(mTypingAction);							}							if (mTypingAction != nil) {								mTypingAction->ForwardErase();							} else {								if ((**mTextEditH).selStart == (**mTextEditH).selEnd) {									::TESetSelect((**mTextEditH).selStart,										(**mTextEditH).selStart + 1, mTextEditH);								}								::TEDelete(mTextEditH);							}							textChanged = true;						}						break;											default:						passUp = true;						break;				}				break;			}							case keyStatus_Reject:				::SysBeep(1);				break;							case keyStatus_PassUp:				passUp = true;				break;		}				qdProcs.ResetProcs();				if (textChanged) {			UserChangedText();		}				if (passUp) {			keyHandled = LCommander::HandleKeyPress(inKeyEvent);		}					// If Target is the same before and after keystroke and			// the selection has changed from empty to not empty or from			// not empty to empty, we need to update menu commands. Some			// command such as Cut and Copy depend on whether or not			// any text is selected.				if ( (theTarget == GetTarget()) &&			 (beforeSel != ((**mTextEditH).selStart == (**mTextEditH).selEnd)) ) {			 			SetUpdateCommandStatus(true);		}				return keyHandled;	}};