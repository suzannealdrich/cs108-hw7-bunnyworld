#include "CPalette.h"#include "CDocumentApp.h"#include "LTabsControl.h"#include <TArray.h>#include <TArrayIterator.h>CPalette::CPalette(LStream *inStream) : LWindow(inStream){}// Initialize varsvoid CPalette::FinishCreateSelf() {	targetShape = NULL; // no target shape yet		// get a link to the popup button	thePopup = (LPopupButton *)CDocumentApp::FindPaneInMyWindow(this,kPopup);	panel = ((LMultiPanelView *)CDocumentApp::FindPaneInMyWindow(this,kMultiPanel));	// Make the second panel, but hide it and switch to the first	LView *scriptPanel = panel->CreatePanel(2);	scriptPanel->Hide();	panel->SwitchToPanel(1);	moveableBox = ((LCheckBox *)CDocumentApp::FindPaneInMyWindow(this,kMoveableBox));	visibleBox = ((LCheckBox *)CDocumentApp::FindPaneInMyWindow(this,kVisibleBox));	scriptEdit = ((CEditField *)CDocumentApp::FindPaneInMyWindow(this,kScriptEdit));	nameEdit = ((LEditText *)CDocumentApp::FindPaneInMyWindow(this,kNameEditFieldID));	// add items to the popup	//*********************************	//*********************************	//*********************************	//********************************* REPLACE THIS EVENTUALLY	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	DM *dm = app->GetData();//	TArray<CResStore*> pictRes = dm->getPictList();	updatePopupValues();	//********************************* REPLACE THIS EVENTUALLY	//*********************************	//*********************************	//*********************************	// listen to the controls	thePopup->AddListener(this);	moveableBox->AddListener(this);	visibleBox->AddListener(this);	scriptEdit->AddListener(this);	nameEdit->AddListener(this);		setTargetShape(NULL);// so it's not enabled without a shape to edit}// sets the target shapevoid CPalette::setTargetShape(CShape *shape) {		// re-draw the shape, probably with grey handles	if (targetShape != NULL) targetShape->Refresh();	CShape *oldShape = targetShape;	targetShape = shape;	// if it's new, the tell me to update everything!	(oldShape != targetShape) ?		updateInfoDisplay(true) :		updateInfoDisplay(false) ;}// simply return pointer to target shape// CShapes use this to determine if they're the targetCShape *CPalette::getTargetShape() { return targetShape; }// don't dismiss editor palettevoid CPalette::ClickInGoAway(							const EventRecord &inMacEvent) {	#pragma unused (inMacEvent)	Hide();}// Listens for:// - shape coord editing// - popup resource changingvoid CPalette::ListenToMessage(	PP_PowerPlant::MessageT		inMessage,	void						*ioParam ){	switch (inMessage) {		case (kSetTop):		case (kSetLeft):		case (kSetBottom):		case (kSetRight):			if (targetShape != NULL) setShapeCoordValues();		break;		/*		case (kNameEditFieldMessage):			setShapeName();		break;*/		case kPopupMessage:			LStr255 *newPict = new LStr255(getPopupSelection(ioParam));			if (targetShape) targetShape->setPict(*newPict);			delete newPict;		break;				case kScriptEdit:			setShapeScript();		break;				case kVisibleBox:			setShapeVisible((((*(int *)ioParam) == 1) ? true : false));			break;		case kMoveableBox:			setShapeMoveable((((*(int *)ioParam) == 1) ? true : false));			break;	}			}void CPalette::AttemptClose() { Hide(); }BooleanCPalette::ObeyCommand(	CommandT	inCommand,	void		*ioParam ){	Boolean	cmdHandled = true;	switch ( inCommand ) {		case cmd_Close:			// don't ever close me, even though I'm targetable			cmdHandled = LCommander::ObeyCommand( inCommand, ioParam );			break;		default:					// Call inherited.			cmdHandled = LWindow::ObeyCommand( inCommand, ioParam );				break;	}	return cmdHandled;}#pragma mark -#pragma mark == Protected CPalette Stuff// update the palette display. Called thru setTargetShape()void CPalette::updateInfoDisplay(bool refreshAll) {//modified by aj to work with new calls.  You know that's bad news.	LStr255 pict;//aj	Assert_(panel);	Boolean move, vis;		// Forcing an update of all the info in the palette	if (refreshAll) {		// is target shape defined (eg, not null)?		// update the resView and the popup				if (targetShape) {						targetShape->getPict(pict);			setPopupSelection(pict);			targetShape->isMoveable(move);			targetShape->isVisible(vis);			setMoveable(move);			setVisible(vis);		} else {			setPopupSelection(NULL);			setMoveable(false);			setVisible(false);		}	// update script; also takes care of null		setName();		setScript();	}		// update coords (takes care of null case	setCoordValues();	// enable or disable palette	if (targetShape != NULL) {		if (! panel->IsEnabled()) panel->Enable();		UpdatePort(); // because the coordinates are changing right now!!	} else {		panel->Disable(); // nothing selected, can't edit the fields	}}// updates the coords of the shape in the text fieldvoid CPalette::setCoordValues() {		LStr255 *emptyString;	LEditText *tex;	Rect shape;	if (! targetShape) {		emptyString = new LStr255(kEmptyString);	} else {		shape = targetShape->ShapeRect();	}		tex = ((LEditText *)CDocumentApp::FindPaneInMyWindow(this,kTop));	(targetShape) ? tex->SetValue(shape.top) : tex->SetText(*emptyString);	tex = ((LEditText *)CDocumentApp::FindPaneInMyWindow(this,kLeft));	(targetShape) ? tex->SetValue(shape.left) : tex->SetText(*emptyString);	tex = ((LEditText *)CDocumentApp::FindPaneInMyWindow(this,kBottom));	(targetShape) ? tex->SetValue(shape.bottom) : tex->SetText(*emptyString);	tex = ((LEditText *)CDocumentApp::FindPaneInMyWindow(this,kRight));	(targetShape) ? tex->SetValue(shape.right) : tex->SetText(*emptyString);	if (! targetShape) delete emptyString;}void CPalette::setName() {		LStr255 *emptyString,shapeName;	Rect shape;	if (targetShape) {		targetShape->getName(shapeName); 		nameEdit->SetDescriptor(shapeName);	} else {		emptyString = new LStr255(kEmptyString);		nameEdit->SetText(*emptyString);		delete emptyString;	}}void CPalette::setShapeName() {		LStr255 name;	if (targetShape) { 			nameEdit = ((LEditText *)CDocumentApp::FindPaneInMyWindow(this,kNameEditFieldID));		nameEdit->GetDescriptor(name);		targetShape->setName(name);		CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();		//app->getCatalog()->UpdateShapes();	}}// sets the coords of the shape from the coords in the text fieldvoid CPalette::setShapeCoordValues() {	LEditText *tex;	tex = ((LEditText *)CDocumentApp::FindPaneInMyWindow(this,kTop));	int left = tex->GetValue();	tex = ((LEditText *)CDocumentApp::FindPaneInMyWindow(this,kLeft));	int top = tex->GetValue();	tex = ((LEditText *)CDocumentApp::FindPaneInMyWindow(this,kBottom));	int bottom = tex->GetValue();	tex = ((LEditText *)CDocumentApp::FindPaneInMyWindow(this,kRight));	int right = tex->GetValue(); 	Point tl = {left,top};	Point br = {bottom,right};	// make sure that there's a target shape to set for!!	if (targetShape) targetShape->SetStartEnd(tl,br);}// returns StringPtr to the text of the selected menu item// ********* WARNING !! ************// IT CREATES NEW MEMORY!!! This must be freed somewhere down the lineStringPtr CPalette::getPopupSelection(void *ioParam) {	Str255 menuName;	if (thePopup) {				// the LMenuController method for this crashes for some reason --		// go straight to toolbox !		::GetMenuItemText(thePopup->GetMacMenuH(),							*((SInt32*)ioParam),							menuName);	}		return StringPtr(menuName);//	return menuName;}// sets the popup selectionvoid CPalette::setPopupSelection(StringPtr newPic) {	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	DM *dm = app->GetData();	TArray<CResStore*> pictRes = dm->getPictList();//-------------	// Do the searching	// This will search the records TArray of resource names for a given	// searchStr name. When it finds it, it will set the corresponding	// selection item. This assumes that the order of the TArray corresponds	// directly to the order of elements in the TArray	//LStr255 *defaultMenuItem = new LStr255(kDefaultMenuItem);	//LStr255 *emptyString = new LStr255(kEmptyString);		int i = 1;		TArrayIterator<CResStore *> iterator(pictRes);	// starts at index 1 by default	CResStore *rec;		while (iterator.Next(rec) != NULL) {	// Copies into the lvalue -- type is correct (int)	// if null search str, then look for default menu item text instead		Str255 recName;		rec->getName(recName);				if (i == 1 && (newPic == NULL || ::EqualString(newPic,kDefaultMenuItem,false,false))) {			thePopup->SetCurrentMenuItem(i);			break;		}		/* BAD STRING CMP CODE || || ::EqualString(newPic,*emptyString,false,false) || 			(newPic == NULL && ::EqualString(recName,*defaultMenuItem,false,false)) ||			(i == 1 && )) { // trying to set newPic to empty string*/				if (::EqualString(newPic,recName,false,false)) {			thePopup->SetCurrentMenuItem(i + 1);			break;		}				i++;	}			//delete defaultMenuItem; // free unused memory	//delete emptyString;//-------------//	CShapeTest::disposeOfArray(availablePicts);	}// this updates the popup menuvoid CPalette::updatePopupValues() {	CDocumentApp *app = (CDocumentApp *)LCommander::GetTopCommander();	TArray<CResStore*> popupList = app->GetData()->getPictList();	// This had better be in a free range, because it will increment this	// and set the value of the menu item to this value. So it's possible if	// you had enough menu items (like 100+), you could set its value to be the	// value of some other menu item somewhere else		int menuItemValue = kMenuItemValue;	StopListening();	thePopup->DeleteAllMenuItems();	thePopup->InsertMenuItem(kDefaultMenuItemPtr,menuItemValue++);	StartListening();		// ADD THE ITEMS -- BE SURE TO INCLUDE THE DEFAULT FIRST ITEM	TArrayIterator<CResStore *> iterator(popupList);	// starts at index 1 by default	CResStore *rec = NULL;	Str255 myType;	Str255 myName;//	Str255 kPictStr = kPICT;	while (iterator.Next(rec)) {		rec->getType(myType);		rec->getName(myName);		if (::EqualString(myType,kPICT,false,false)) {			int i = 0;			thePopup->InsertMenuItem(myName,menuItemValue++);					}	}		// update the selected stuff	if (targetShape) {		Str255 pictName;		targetShape->getPict(pictName);		setPopupSelection(pictName);	}}// sets the moveable value of the checkboxvoid CPalette::setMoveable(bool moveable) {	moveableBox->SetValue(moveable);}// sets moveable for shapevoid CPalette::setShapeMoveable(bool moveable) {	if (targetShape) targetShape->setMoveable(moveable);}// sets the visible for checkboxvoid CPalette::setVisible(bool visible) { 	visibleBox->SetValue(visible); }// sets the visible for shapevoid CPalette::setShapeVisible(bool visible) {	if (targetShape) targetShape->setVisible(visible);}// set the script edit box's valuevoid CPalette::setScript() {Str255 script;//ajStringPtr script = 		if (targetShape) {		targetShape->getScript(script);		int len = StrLength(script);		if (script != NULL) {			// this is wack. I have to convert script to a			// StringPtr (unsigned char *), then cast it to a			// char *. But it still has that pascal char at the			// beginning, so I have to take that out. BULLSH!T			scriptEdit->SetTextPtr((char *)script + sizeof(char),len);			return;		}			}	// nothing to set for the shape, so fill it with an empty string	LStr255 *emptyString = new LStr255(kEmptyString);	StringPtr foo = *emptyString;	scriptEdit->SetTextPtr((char *)foo,emptyString->Length());	delete emptyString;		}// sets the shape's script// ********* WARNING !! ************// IT CREATES NEW MEMORY!!! This must be freed somewhere down the linevoid CPalette::setShapeScript() {	CharsHandle	theText = ::TEGetText(scriptEdit->GetMacTEH());	Size textLen	= ::GetHandleSize(theText);	// equally wack. I have to cast my perfectly fine char * as a 	// void *, then send its length in order to get the LStr255 	// to take it correctly	LStr255 *newScript = new LStr255((void *)(*theText),textLen);	if (targetShape) targetShape->setScript(*newScript);		delete newScript;}#pragma mark -#pragma mark ==Testbed// CREATE A DUMMY ARRAY// This should be replaced by a call to the data model eventually// right now just testbed codeTArray<LStr255*> *CPalette::getPictsArray() {	TArray<LStr255*> *records = new TArray<LStr255*>;	LStr255 *select = new LStr255(kMenuItemSelect);	LStr255 *foobar1 = new LStr255(kMenuItem1);	LStr255 *foobar2 = new LStr255(kMenuItem2);	LStr255 *foobar3 = new LStr255(kMenuItem3);	LStr255 *foobar4 = new LStr255(kMenuItem4);	records->AddItem(select);	records->AddItem(foobar1);	records->AddItem(foobar2);	records->AddItem(foobar3);	records->AddItem(foobar4);	return records;}// This will delete memory assoc. with the TArrayvoid CPalette::disposeOfArray(TArray<LStr255*> *records) {	TArrayIterator<LStr255 *> iterator(*records);	// starts at index 1 by default	LStr255 *rec;		while (iterator.Next(rec))		delete rec;	delete records;}