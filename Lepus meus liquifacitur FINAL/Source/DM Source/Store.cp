// Store.cp#include "Store.h"/* A simple key/value storage object. Associates a key with a value. Later you can retrieve or change the value associated with a key. Keys and values are both generic void* types.  This is a useful object to have around to take care of the grunt work of storing arbitrarily sized and changing data using a key/value format.   Use Set to add/change the value for a key. Use Find to retrieve the value for a key. Use Export/Import to archive the whole Store to a block of memory. Use WriteToStream/OrientFromStream for streaming.  There are accessors for the common cases where the key is a pascal string and the value is a string, int, or pointer. SetString, SetInt32, SetPtr ... These are a convenience-- they all just call the real Set and Find to do the real work.  Internally, this stores a single contiguous block of memory which looks like key0 value0 key1 value1 ... The implementation is a bit complex in the classic malloc(), ptr++, CS107 style of C hacking. Each key or value is stored as a "unit" which is an Int32 size followed immediately by the data. Given that we always store key value pairs, the number of units will always be even. The data in a unit is overallocated slightly so it takes up a multiple of 4 bytes -- that way the next unit will be aligned.  HANDLE -- later added special case capability so if the Store contains a pointer key called "\phandle", then the Store will assume the value is a handle and it will... 1) delete the handle when it is destructed 2) write the handle to a stream when the store is written 3) restore the handle when the store is read  There's a constant named HANDLE which has the value "\phandle".  See the DM class for a simple Store client.  96 Nov 20 Initial release	njp  97 Nov 16 Minor Revisions	njp 	96 code appears to be bug free (?!) 	Added const to a bunch of parameters 	Changed Findxxx variants to set the result param to 0 when not found 	Changed xxxBlock to xxxData for streaming 	Added code to DM sample code to demonstrate using LStr255 	Added the DebugStateToString() 	Added the constant key syntax for things like HANDLE and NAME 	Added private operator= and copy constructor*/Store::Store() {	mSize = 0;	mAllocSize = 0;	mData = NULL;}Store::~Store() {	Handle handle;		if (FindPtr(HANDLE, handle)) {		::DisposeHandle(handle);	}		delete mData;}// A size s  in bytes, rounded up to the next multiple of modulus m#define MOD_UP(s, m) ((s) + ( ((s)%(m)) ? ((m) - ((s)%(m))) : 0))// Internal allocation rounds up to this modulus//  helps alignment and space re-use as values change#define INTERNAL_MOD 4// Used to round up internal sizes, eg 3 becomes 4#define INTERNAL_UP(s) MOD_UP(s, INTERNAL_MOD)// The allocation modulus used for the whole data block -- see Resize()#define BLOCK_MOD 32// Macros to take apart a size/data unit// Given a ptr to a size/data unit, return the int size of the data#define SIZE(ptr)	(*(Int32*)(ptr))// Given a ptr to a size/data unit, return a pointer to the data#define DATA(ptr)	(((char*)(ptr)) + sizeof(Int32))// Given a ptr to a size/data unit, return a pointer to the next unit#define NEXT(ptr) (((char*)ptr) + INTERNAL_UP(SIZE(ptr)) + sizeof(Int32))// These are arbitrary sanity-check constraints just used for Assert calls.// Feel free to increase or delete them.#define KEY_MAX 256#define DATA_MAX (16 * 1024L)/* Internal utility. True if two blocks are, byte by byte, the same. Looking at the disassembly for this gives you a quick sense of how well your compiler generates code.*/static Boolean ByteCompare(const void  * a, const void  * b,  Int32 aLen) {	Int32 i;		for (i=0; i<aLen; i++) {		if (((char*)a)[i] != ((char*)b)[i]) return(false);	}		return(true);}/* Search for the given key. If found, return a pointer to that key's data in the store. Compares keys byte by byte. The pointer returned is into the Store's own memory, so it is only valid so long as the Store does not change. Returns false and outData is NULL if there is no matching key.  The keyUnit param will return a pointer to the key unit part of the key/value pair if there is a match. This is used inernally by Set() so it can delete the old pair. Regular clients should pass NULL.*/Boolean Store::Find(const void* key, Int32 keySize, void*& outData, Int32& outDataSize, void** keyUnit) {	char* current = mData;	char const * end = mData + mSize;			outData = NULL;	outDataSize = 0;		Assert_(keySize > 0);	Assert_(keySize <= KEY_MAX);		while (current < end) {		Int32 aKeySize = SIZE(current);	// get the key from the pair		char* aKeyData = DATA(current);				Assert_(aKeySize > 0);		Assert_(aKeySize <= KEY_MAX);				if ((keySize == aKeySize) && ByteCompare(key, aKeyData, keySize)) {	// found it!			if (keyUnit) *keyUnit = current;	// note the key unit if the client wants it			current = NEXT(current);	// skip current to point to the next elt -- the data			outDataSize = SIZE(current);			outData = DATA(current);						Assert_(outDataSize > 0);			Assert_(outDataSize <= DATA_MAX);						return(true);		}				// skip twice to get to the next key		current = NEXT(current);		Assert_(current < end);		current = NEXT(current);		}		return(false);}/* Internal utility. Used to change the allocated size of mData, possibly copying over the old data. Used by Set() and Import().*/void Store::ChangeAlloc(Int32 newSize, Boolean copyOld) {	Assert_(newSize >= INTERNAL_MOD);		if (newSize <= mAllocSize) {		return;	}	else {		Int32 newAllocSize = MOD_UP(newSize, BLOCK_MOD);						char* newData = new char[newAllocSize];		Assert_(newData != NULL);				if (copyOld) {			::BlockMoveData(mData, newData, mSize);		}		delete(mData);				mData = newData;		mAllocSize = newAllocSize;	}}/* Internal utility. Takes a pointer to a  size/data unit. Deletes the given number of units starting there. Only makes sense to delete an even numbers of units.*/void Store::Delete(char* target, Int32 count) {	Assert_((count % 2) == 0);		int i;	char* end = target;		for (i=0; i<count; i++) {		end = NEXT(end);		Assert_(end <= mData + mSize);	}		// delete everything between target and end			Int32 delSize = end - target;		if (end < (mData + mSize)) {		::BlockMoveData(end, target, (mData+mSize) - end);	// copy "tail" back to target	}		mSize -= delSize;}/* Add the given key/value pair to the store. Replaces an existing entry or adds one if it was not there before. Copies the given data into its own storage. In some cases, this may need to move the allocation of the whole Store around.*/void Store::Set(const void* key, Int32 keySize, const void* data, Int32 dataSize) {	char* xData;	Int32 xSize;	char* keyUnit;		Assert_(keySize > 0);	Assert_(keySize <= KEY_MAX);		Assert_(dataSize > 0);	Assert_(dataSize <= DATA_MAX);		// See if it's in there already	Find(key, keySize, xData, xSize, &keyUnit);		if (xData != NULL) {	// it's there already		if (INTERNAL_UP(xSize) == INTERNAL_UP(dataSize)) {	// can re-use the old slot			*((Int32*)xData-1) = dataSize;			::BlockMoveData(data, xData, dataSize);			return;		}		else {			Delete(keyUnit, 2);	// delete the key and its value		}	}		// At this point, add it at the end		ChangeAlloc(mSize + INTERNAL_UP(keySize) + INTERNAL_UP(dataSize) + 2*sizeof(Int32));		// write the key	char* target = mData + mSize;	*((Int32*)target) = keySize;	target += sizeof(Int32);	::BlockMoveData(key, target, keySize);	target += INTERNAL_UP(keySize);		*((Int32*)target) = dataSize;	target += sizeof(Int32);	::BlockMoveData(data, target, dataSize);		mSize += INTERNAL_UP(keySize) + INTERNAL_UP(dataSize) + 2*sizeof(Int32);	Assert_(mSize <= mAllocSize);}/* Returns a pointer to the current Store state and its size. Copy these bytes away somewhere, and you can use them later in a call to ImportData(). The Store retains ownership of its memory. The data block does not rely on any pointers for its implementation, so it can be archived, and used to recreate a Store later.  Note-- this does not do anything special to deal with an embedded HANDLE entry.*/void Store::ExportData(void*& data, Int32& size) {	data = mData;	size = mSize;}/* Copies in and orients to the given block of data. The block of data should have previously come from a call to ExportData(). Completely replaces any previous contents of the Store. The caller retains ownership of the memory.*/void Store::ImportData(void* newData, Int32 newSize) {	ChangeAlloc(newSize, false);		::BlockMoveData(newData, mData, newSize);	mSize = newSize;}	/* Write the store length followed by its data.  HANDLE: if the store contains a handle ptr, write it out on the stream following the store itself. The one cheesy thing is that we write out the current pointer value of the handle in the Store block -- this pointer value gets overwritten immediately when the Store is read in.*/void Store::WriteToStream(LStream *out) {	void* storeMem;	Int32 storeSize;		ExportData(storeMem, storeSize);	// get the memory and size for our state		out->WriteData(&storeSize, sizeof(storeSize));	// write the size	out->WriteData(storeMem, storeSize);	// write the bytes		Handle handle;	// if the store contains a field called "handle"...	if (FindPtr(HANDLE, handle)) {		out->WriteHandle(handle);	}}	/* Read the Store block into temporary memory and then orient to it.  Blindly overwrites any existing state.  HANDLE: if the store contains a "\phandle" entry, then the handle is next in the stream. Read it in, and set the "handle" entry to contain the handle value.*/void Store::OrientFromStream(LStream *in) {	void* storeMem;	Int32 storeSize;		in->ReadData(&storeSize, sizeof(Int32));		storeMem = new char[storeSize];	Assert_(storeMem != NULL);	// could throw out-o-mem error here		in->ReadData(storeMem, storeSize);		ImportData(storeMem, storeSize);	// orient to the read in state		delete storeMem;		Handle oldH;	// if the store contains a field called "handle"...	Handle newH;	if (FindPtr(HANDLE, oldH)) {		in->ReadHandle(newH);		SetPtr(HANDLE, newH);	// put in the newly allocate and read in handle	}}/* Convenient Accessors which call Set and Find to do the work. Keys must be byte-by-byte the same to match. Everything uses copy-in/copy-out memory mangement. For setting, the store makes its own copy of the client's data. For finding, the store copies the data out for the client if found, and returns false and sets the client data to 0 if not found.*/void Store::SetString(ConstStringPtr key, ConstStringPtr value) {	Set((void*)key, key[0]+1, value, value[0]+1);}Boolean Store::FindString(ConstStringPtr key, Str255 outValue) {	char* result;	Int32 size;	if (Find(key, key[0]+1, result, size)) {		Assert_(size<=256);		::BlockMoveData(result, outValue, size);		return(true);	}	else {		outValue[0] = '\0';	// set the length byte to 0		return(false);	}}void Store::SetPtr(ConstStringPtr key, const void* ptr) {	Set(key, key[0]+1, &ptr, sizeof(void*));}Boolean Store::FindPtr(ConstStringPtr key, void*& outPtr) {	void** result;	Int32 size;	if (Find(key, key[0]+1, result, size)) {		Assert_(size == sizeof(void*));		outPtr = *result;		return(true);	}	else {		outPtr = 0;		return(false);	}}void Store::SetInt32(ConstStringPtr key, Int32 value) {	Set(key, key[0]+1, &value, sizeof(Int32));}Boolean Store::FindInt32(ConstStringPtr key, Int32& outValue) {	Int32* result;	Int32 size;	if (Find(key, key[0]+1, result, size)) {		Assert_(size == sizeof(Int32));		outValue = *result;		return(true);	}	else {		outValue = 0;		return(false);	}}void Store::SetInt16(ConstStringPtr key, Int16 value) {	Set(key, key[0]+1, &value, sizeof(Int16));}Boolean Store::FindInt16(ConstStringPtr key, Int16& outValue) {	Int16* result;	Int32 size;	if (Find(key, key[0]+1, result, size)) {		Assert_(size == sizeof(Int16));		outValue = *result;		return(true);	}	else {		outValue = 0;		return(false);	}}/* Attempt to dump all of the attr/value bindings into a string. This is just a convenience for debugging so you can get a quick idea of the contents of a Store. Things which don't fit are truncated. Pass the string to DebugStr() or SignalPStr_() to see it.  Format is attr0,value0,attr1,value1,... Pascal strings print as themselves. 2 and 4 byte values print as ints. Other things print as '_'.*/void Store::DebugStateToString(Str255 output) {	char* current = mData;	char const * end = mData + mSize;	Str255 local;		*output = '\0';			while (current < end) {		Int32 size = SIZE(current);		unsigned char* data = (unsigned char*)DATA(current);		Assert_(size > 0);		Assert_(size <= DATA_MAX);				// if it's a string, the size and the length byte will agree..		if (size == *data + 1) {	// guess its a string			if (*data == '\0') LString::AppendPStr(output, "\pempty string", 255);			else LString::AppendPStr(output, data, 255);		}		else if (size == 2) {	// guess its a short			Int32 num = *(Int16*)data;			::NumToString(num, local);			LString::AppendPStr(output, local, 255);		}		else if (size == 4) {	// guess its a long			Int32 num = *(Int32*)data;			::NumToString(num, local);			LString::AppendPStr(output, local, 255);		}		else LString::AppendPStr(output, "\p_", 255);	// otherwise print _				LString::AppendPStr(output, "\p,", 255);				current = NEXT(current);	}}