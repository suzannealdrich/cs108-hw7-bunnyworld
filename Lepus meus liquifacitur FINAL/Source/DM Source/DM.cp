// DM.cp// Mar 99 - Hacked for BunnyWorld - sja#include "DM.h"#include <TArray.h>#include <TArrayIterator.h>#include "CPageStore.h"#include "CShapeStore.h"#include "CResStore.h"#include "CDocumentApp.h"#include "CCanvas.h"//#include <UDebugging.h>// Constructor...nothing to doDM::DM() {}// Destructor...clean up arraysDM::~DM() {	removeAllStores();}// WriteToFile...write out length of each array followed by its storesvoid DM::WriteToFile(LFileStream* file) {	Int32 count;		file->OpenDataFork(fsRdWrPerm);	count = mPages.GetCount();				// write the number of pages	file->WriteData(&count, sizeof(count));		TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	while (pagerator.Next(currentPage)) {		 currentPage->WriteToStream(file);	}		count = mShapes.GetCount();				// write the number of shapes	file->WriteData(&count, sizeof(count));		TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	while (shaperator.Next(currentShape)) {		 currentShape->WriteToStream(file);	}		count = mPicts.GetCount();				// write the number of picts	file->WriteData(&count, sizeof(count));		TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	while (picterator.Next(currentPict)) {		 currentPict->WriteToStream(file);	}		count = mSounds.GetCount();				// write the number of sounds	file->WriteData(&count, sizeof(count));		TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	while (sounderator.Next(currentSound)) {		 currentSound->WriteToStream(file);	}		file->SetLength(file->GetMarker());	file->CloseDataFork();}// ReadFromFile...read in length of each array followed by its storesvoid DM::ReadFromFile(LFileStream* file) {	Int32 count, i;		removeAllStores();			file->OpenDataFork(fsRdPerm);			file->ReadData(&count, sizeof(Int32));	// read the number of pages		for (i = 0; i < count; i++) {		CPageStore* currentPage = newPageStore();		currentPage->OrientFromStream(file);	}		file->ReadData(&count, sizeof(Int32));	// read the number of shapes		for (i = 0; i < count; i++) {		CShapeStore* currentShape = newShapeStore();		currentShape->OrientFromStream(file);	}			file->ReadData(&count, sizeof(Int32));	// read the number of picts		for (i = 0; i < count; i++) {		CResStore* currentPict = newResStore(kPICT);		currentPict->OrientFromStream(file);	}			file->ReadData(&count, sizeof(Int32));	// read the number of sounds		for (i = 0; i < count; i++) {		CResStore* currentSound = newResStore(SOUND);		currentSound->OrientFromStream(file);	}			file->CloseDataFork();}#pragma mark -// getTotalPages...return number of pagesint DM::getTotalPages() {	return mPages.GetCount();}// newPageStore...allocate page, enter it into mPages, and return pointerCPageStore* DM::newPageStore() {	CPageStore* page = new CPageStore();		mPages.AddItem(page);		return page;}// getPageStore...given its number, search for page in mPages and return pointer;// if not found return NULLCPageStore* DM::getPageStore(Int32 pageNum) {	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	Int32 currentNum;		while (pagerator.Next(currentPage)) {		currentPage->getPage(currentNum);		if (currentNum == pageNum) 			return currentPage;	}		return NULL;}// getPageStore...given its name, search for page in mPages and return pointer;// if not found or NULL name, return NULLCPageStore* DM::getPageStore(ConstStringPtr name) {	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	Str255 currentName;		if (name) {		while (pagerator.Next(currentPage)) {			currentPage->getName(currentName);			if (currentName && ::EqualString(currentName, name, false, false)) 				return currentPage;		}	}		return NULL;}// getShapesInPage...given its number, return array of pointers to shapes in that pageTArray<CShapeStore*> DM::getShapesInPage(Int32 pageNum) {	TArray<CShapeStore*> pageShapes;	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Int32 currentNum;		while (shaperator.Next(currentShape)) {		currentShape->getPage(currentNum);		if (currentNum == pageNum)  {			pageShapes.AddItem(currentShape);		}	}		return pageShapes;}// getPageList...return name-sorted array of pointers to all pagesTArray<CPageStore*> DM::getPageList() {	CStoreNameComparator* compFn = new CStoreNameComparator;	TArray<CPageStore*> allPages(compFn, true);	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;		while (pagerator.Next(currentPage)) {		 allPages.AddItem(currentPage);	}		return allPages;}// removePageStore...given its name, delete page and its shapes;// does nothing if NULL namevoid DM::removePageStore(ConstStringPtr name) {	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	Str255 currentName;	Int32 pageNum;		if (!name) return;		while (pagerator.Next(currentPage)) {		currentPage->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) {			currentPage->getPage(pageNum);			mPages.RemoveItemsAt(1, pagerator.GetCurrentIndex());			delete currentPage;		}	}		removeShapesInPage(pageNum);	updatePageNums(pageNum);}// removePageStore...given its number, delete page and its shapes;// adjust page numbering to fill in holevoid DM::removePageStore(Int32 pageNum) {	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	Int32 currentNum;		while (pagerator.Next(currentPage)) {		currentPage->getPage(currentNum);		if (currentNum == pageNum) {			mPages.RemoveItemsAt(1, pagerator.GetCurrentIndex());			delete currentPage;		}	}		removeShapesInPage(pageNum);	updatePageNums(pageNum);	}#pragma mark -// getTotalShapes...return number of shapesint DM::getTotalShapes() {	return mShapes.GetCount();}// newShapeStore...allocate shape, enter it into mShapes, and return pointerCShapeStore* DM::newShapeStore() {	CShapeStore* shape = new CShapeStore();		mShapes.AddItem(shape);		return shape;}// getShapeStore...given its name, search for shape in mShapes and return pointer;// if not found or NULL name return NULLCShapeStore* DM::getShapeStore(ConstStringPtr name) {	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Str255 currentName;		if (name) {		while (shaperator.Next(currentShape)) {			currentShape->getName(currentName);			if (currentName && ::EqualString(currentName, name, false, false))				return currentShape;		}	}		return NULL;}// updateShapePicts...given the old pict, updates all relevant shapes to use new pict, // or NULL; can also update shapes with NULL old picts to use new pictvoid DM::updateShapePicts(ConstStringPtr oldPict, ConstStringPtr newPict) {	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Str255 currentPict;		 	Int32 curPage;	CDocumentApp *app = ((CDocumentApp *)LCommander::GetTopCommander());	app->getCurrentPageNum(curPage);		while (shaperator.Next(currentShape)) {		Int32 myPage;				currentShape->getPage(myPage);		currentShape->getPict(currentPict);		// allows NULL picts to be updated and allows updates to NULL		if ((!oldPict && !currentPict) 			|| (oldPict && currentPict && ::EqualString(currentPict, oldPict, false, false))) {			currentShape->setPict(newPict);			if (myPage == curPage) { 			// must redraw the canvas if removing shape currently on display!!				CCanvas *canvas = (CCanvas *)app->getCanvas();				canvas->Refresh();			}		}	}}// updateShapePages...given the old page number, updates all relevant shapes // to use new numbervoid DM::updateShapePages(Int32 oldNum, Int32 newNum) {	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Int32 currentPage;		 	while (shaperator.Next(currentShape)) {		currentShape->getPage(currentPage);		if (currentPage == oldNum) {			currentShape->setPage(newNum);		}	}}// getShapeList...return name-sorted array of pointers to all shapesTArray<CShapeStore*> DM::getShapeList() {	CStoreNameComparator* compFn = new CStoreNameComparator;	TArray<CShapeStore*> allShapes(compFn, true);	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;		while (shaperator.Next(currentShape)) {		 allShapes.AddItem(currentShape);	}		return allShapes;}// removeShapeStore...given its name, delete shape;// does nothing if NULL namevoid DM::removeShapeStore(ConstStringPtr name) {	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Str255 currentName;		if (!name) return;		while (shaperator.Next(currentShape)) {		currentShape->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) {			mShapes.RemoveItemsAt(1, shaperator.GetCurrentIndex());			delete currentShape;		}	}}#pragma mark -// getTotalPicts...return number of picturesint DM::getTotalPicts() {	return mPicts.GetCount();}// getTotalSounds...return number of soundsint DM::getTotalSounds() {	return mSounds.GetCount();}// newResStore...allocate res, enter it into mPicts or mSounds, and return pointer// if type is NULL return NULLCResStore* DM::newResStore(ConstStringPtr type) {	CResStore* res = new CResStore(type);		if (!type) return NULL;		if (::EqualString(kPICT, type, false, false)) {		mPicts.AddItem(res);	} else 	if (::EqualString(SOUND, type, false, false)) {		mSounds.AddItem(res);	}		return res;}// getPictResStore...given its name, search for pict in mPicts and return pointer;// if not found or name is NULL return NULLCResStore* DM::getPictResStore(ConstStringPtr name) {	Str255 currentName;	TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;		if (name) {		while (picterator.Next(currentPict)) {			currentPict->getName(currentName);			 if (currentName && ::EqualString(currentName, name, false, false)) 			 	return currentPict;		}	}		return NULL;}// getSoundResStore...given its name, search for sound in mSounds and return pointer;// if not found or name is NULL return NULLCResStore* DM::getSoundResStore(ConstStringPtr name) {	Str255 currentName;	TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;		if (name) {		while (sounderator.Next(currentSound)) {			currentSound->getName(currentName);			if (currentName && ::EqualString(currentName, name, false, false)) 				return currentSound;		}	}		return NULL;}// getPictList...return name-sorted array of pointers to all pictsTArray<CResStore*> DM::getPictList() {	CStoreNameComparator* compFn = new CStoreNameComparator;	TArray<CResStore*> allPicts(compFn, true);	TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;		while (picterator.Next(currentPict)) {		 allPicts.AddItem(currentPict);	}		return allPicts;}// getSoundList...return name-sorted array of pointers to all soundsTArray<CResStore*> DM::getSoundList() {	CStoreNameComparator* compFn = new CStoreNameComparator;	TArray<CResStore*> allSounds(compFn, true);	TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;		while (sounderator.Next(currentSound)) {		 allSounds.AddItem(currentSound);	}		return allSounds;}// removePictResStore...given its name, delete pict and update shapes to use NULL pict;// does nothing if name is NULLvoid DM::removePictResStore(ConstStringPtr name) {	TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	Str255 currentName;		if (!name) return;		while (picterator.Next(currentPict)) {		currentPict->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) {			updateShapePicts(currentName, kDefaultMenuItem);	// ?			mPicts.RemoveItemsAt(1, picterator.GetCurrentIndex());			delete currentPict;		}		}}// removeSoundResStore...given its name, delete sound;// does nothing if name is NULLvoid DM::removeSoundResStore(ConstStringPtr name) {	TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	Str255 currentName;		if (!name) return;		while (sounderator.Next(currentSound)) {		currentSound->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) {			mSounds.RemoveItemsAt(1, sounderator.GetCurrentIndex());			delete currentSound;		}		}}#pragma mark -// updatePageNums...void DM::updatePageNums(Int32 deletedNum) {	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	Int32 currentNum;		while (pagerator.Next(currentPage)) {		currentPage->getPage(currentNum);		if (currentNum > deletedNum) currentPage->setPage(currentNum - 1);	}}// removeShapesInPage...given the number of their page, delete all shapes in pagevoid DM::removeShapesInPage(Int32 pageNum) {	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Int32 currentNum;		while (shaperator.Next(currentShape)) {		currentShape->getPage(currentNum);		if (currentNum == pageNum)  {			mShapes.RemoveItemsAt(1, shaperator.GetCurrentIndex());			delete currentShape;		}	}}// removeAllStores...delete all storesvoid DM::removeAllStores() {	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	while (shaperator.Next(currentShape)) {		mShapes.RemoveItemsAt(1, shaperator.GetCurrentIndex());		delete currentShape;	}		TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	while (pagerator.Next(currentPage)) {		mPages.RemoveItemsAt(1, pagerator.GetCurrentIndex());		delete currentPage;	}		TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	while (picterator.Next(currentPict)) {		mPicts.RemoveItemsAt(1, picterator.GetCurrentIndex());		delete currentPict;	}		TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	while (sounderator.Next(currentSound)) {		mSounds.RemoveItemsAt(1, sounderator.GetCurrentIndex());		delete currentSound;	}}void DM::Soil(bool isDirty) {	((CDocumentApp *)LCommander::GetTopCommander())->SetDirty(isDirty);}#pragma mark -CStoreNameComparator::CStoreNameComparator(){}CStoreNameComparator::~CStoreNameComparator(){}SInt32 CStoreNameComparator::Compare(const void* inItemOne, const void* inItemTwo,										UInt32 inSizeOne, UInt32 inSizeTwo) const{	Str255 oneNameArr, twoNameArr;	Store** storeOne = (Store**)inItemOne;	Store** storeTwo = (Store**)inItemTwo;		(*storeOne)->FindString(kNAME, oneNameArr);	(*storeTwo)->FindString(kNAME, twoNameArr);	LStr255 oneName(oneNameArr);	LStr255 twoName(twoNameArr);	Int32 result = LString::CompareIgnoringCase((char *)oneNameArr + sizeof(char), (char *)twoNameArr + sizeof(char), oneName.Length(), twoName.Length());	//Int32 result = LString::CompareBytes(oneName, twoName, oneName.Length(), twoName.Length());	return (result);}