// Store.h/* Provides a generic key/value storage object. Supports adding, retrieving, and archiving. See the .cp file for details.*/#pragma onceclass Store {public:	Store();	~Store();		void Set(const void* key, Int32 keySize, const void* data, Int32 dataSize);	Boolean Find(const void* key, Int32 keySize, void*& outData, Int32& outDataSize, void** keyUnit = NULL);		void ExportData(void*& data, Int32& size);	void ImportData(void* newData, Int32 newSize);		void WriteToStream(LStream *out);	void OrientFromStream(LStream *in);	// These are convenient specializations of Set and Find	// which assume that the key is always an Str255	void SetString(ConstStringPtr atrribute, ConstStringPtr value);	Boolean FindString(ConstStringPtr key, Str255 outValue);	void SetInt32(ConstStringPtr key, Int32 value);	Boolean FindInt32(ConstStringPtr key, Int32& outValue);	void SetInt16(ConstStringPtr key, Int16 value);	Boolean FindInt16(ConstStringPtr key, Int16& outValue);	void SetPtr(ConstStringPtr key, const void* ptr);	Boolean FindPtr(ConstStringPtr key, void*& outPtr);		// Snapshot the state into a string for debugging	void DebugStateToString(Str255 output);		protected:	void ChangeAlloc(Int32 newSize, Boolean copyOld = true);	void Delete(char* target, Int32 count);		Int32 mSize;	Int32 mAllocSize;	char* mData;		// These are added as private: so that accidental copying with = or// constructors will not work -- use export/import or streaming to manipulate// a Store at the macro level like that.private:	void operator=(const Store&) {}	// no operator=	Store(const Store&) {}	// no copy constructor};// This key name triggers the special "handle" behavior// This sort of const declaration is a handy way to specify your// key names.const  ConstStringPtr HANDLE = "\phandle";