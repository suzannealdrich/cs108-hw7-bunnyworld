// =================================================================================//	CDocumentApp.cp					©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================//	This file contains the starter code for a document PowerPlant project////  The Application is derived from LDocApplication.  New Windows are managed//  by CTextDocument which is derived from LSingleDoc.  Each document contains//  a smart text view that remembers if it has changed since it was last saved.#include "CDocumentApp.h"#include <StandardFile.h>#include <LGrowZone.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <PPobClasses.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <URegistrar.h>#include <UTextTraits.h>#include <UStandardDialogs.h>// Appearance incs#include <LWindow.h>#include <LCaption.h>#include <UGraphicUtils.h>#include <UEnvironment.h>#include "UGAColorRamp.h"#include <LActiveScroller.h>#include <LWindow.h>#include <LPrintout.h>#include <LPlaceHolder.h>#include "CToolPaletteButton.h"#include "CCanvas.h"#include "MiniConstants.h"#include "LGAColorSwatchControl.h"#include "CSwatch.h"// Bunny Include#include <Appearance.h>#include <UControlRegistry.h>#include "CEditText.h"#include "CResDraw.h"#include "CEditField.h"#include "CPosessions.h"#include "CNameEditText.h"//#include "CCatalogWin.h"// script include#include "CScriptParser.h"#include "CScriptAction.h"// Suz Bunny Include#include "CBunnyDoc.h"#include "DM.h"#include "CPageStore.h"#include "CShapeStore.h"#include "CResStore.h"#include "CSoundButton.h"#include "LString.h"//table#include "TablesConstants.h"//#include "CCatalog.h"// =================================================================================//		¥ Main Program// ===========================================================================int main(){									SetDebugThrow_(PP_PowerPlant::debugAction_Alert);	// Set Debugging options	SetDebugSignal_(PP_PowerPlant::debugAction_Alert);	PP_PowerPlant::InitializeHeap(3);					// Initialize Memory Manager														// Parameter is number of Master Pointer														// blocks to allocate		PP_PowerPlant::UQDGlobals::InitializeToolbox(&qd);	// Initialize standard Toolbox managers		new PP_PowerPlant::LGrowZone(20000);				// Install a GrowZone function to catch														// low memory situations.	CDocumentApp	theApp;								// create instance of your application	theApp.Run();		return 0;}// ---------------------------------------------------------------------------------//		¥ CDocumentApp// ---------------------------------------------------------------------------------//	ConstructorCDocumentApp::CDocumentApp(){	PP_PowerPlant::RegisterAllPPClasses();		// Register functions to create core	if ( PP_PowerPlant::UEnvironment::HasFeature( PP_PowerPlant::env_HasAppearance ) ) {		::RegisterAppearanceClient();	}	RegisterClass_(PP_PowerPlant::LWindow);			// You must register each kind of	RegisterClass_(PP_PowerPlant::LActiveScroller);	// PowerPlant classes that you use	RegisterClass_(PP_PowerPlant::LPrintout);		// in your PPob resource.	RegisterClass_(PP_PowerPlant::LPlaceHolder);	RegisterClass_(PP_PowerPlant::LRadioGroupView);	RegisterClass_(PP_PowerPlant::LGAColorSwatchControl);	RegisterClass_(PP_PowerPlant::LOffscreenView);			// Register the Appearance Manager/GA classes - bunny	// BUNNY START	PP_PowerPlant::UControlRegistry::RegisterClasses();	RegisterClass_(PP_PowerPlant::LView);	RegisterClass_(PP_PowerPlant::LEditField);	RegisterClass_(PP_PowerPlant::LPane);	RegisterClass_(CPalette);	RegisterClass_(CResDraw);	RegisterClass_(CEditField);	RegisterClass_(CCatalogWin);		RegisterClass_(LTabGroup);	RegisterClass_(PP_PowerPlant::LTextEditView);	RegisterClass_(PP_PowerPlant::LPaintAttachment);	RegisterClass_(PP_PowerPlant::LBorderAttachment);	// BUNNY END	RegisterClass_(PP_PowerPlant::LPicture);	RegisterClass_(PP_PowerPlant::LCicnButton);	RegisterClass_(PP_PowerPlant::LStdButton);	RegisterClass_(PP_PowerPlant::LCaption);		RegisterClass_(CToolPalette);	RegisterClass_(CToolPaletteButton);	RegisterClass_(CCanvas);	RegisterClass_(CSwatch);	RegisterClass_(CEditText);	RegisterClass_(CSoundButton);	RegisterClass_(CNameEditText);		// table	RegisterClass_(LTableView);	RegisterClass_(LHierarchyTable);	RegisterClass_(CCatalog);		PP_PowerPlant::PP_StandardDialogs::Load();		// Preload facilities for std dialogs		//dM = new DMAp();//Added for testing of CCanvas AJ 3/1	playMode = false;		//	mBookmarksWindow = MakeBookmarksWindow();//	ThrowIfNil_( mBookmarksWindow );	}// ---------------------------------------------------------------------------------//		¥ ~CDocumentApp// ---------------------------------------------------------------------------------//	DestructorCDocumentApp::~CDocumentApp(){	PP_PowerPlant::PP_StandardDialogs::Unload();	// Clean up after std dialogs	FSSpec inFileSpec;	// clean up our prefs file which acts as a temp	mPrefsFile->GetSpecifier(inFileSpec);	OSErr whoCares = ::FSpDelete(&inFileSpec );	delete mPrefsFile;}// ---------------------------------------------------------------------------------//		¥ StartUp// ---------------------------------------------------------------------------------//	This function lets you do something when the application starts up//	without a document. For example, you could issue your own new command.voidCDocumentApp::StartUp(){// BUNNY: NO NEW FOR YOU!!!!//	ObeyCommand( PP_PowerPlant::cmd_New, nil );		// LDocApplication::ObeyCommand													// handles this command}// ---------------------------------------------------------------------------------//		¥ OpenDocument// ---------------------------------------------------------------------------------// This method is called when a file is chosen from the StandardFile Open Dialog// File_Menu->Open item.voidCDocumentApp::OpenDocument(	FSSpec	*inMacFSSpec ){	PP_PowerPlant::LDocument	*theDoc = PP_PowerPlant::LDocument::FindByFileSpec(*inMacFSSpec);		// If the document is already open, make it the current document	if (theDoc != nil) {						theDoc->MakeCurrent();			// otherwise, make a new Document	} else {									// refresh the data model and the palette		delete mData;		mData = new DM();		bDoc = theDoc = new CBunnyDoc(this, inMacFSSpec);		bunpal->updatePopupValues(); // BUNNY		catalog->UpdateWholeList();	}			}// ---------------------------------------------------------------------------------//		¥ MakeNewDocument// ---------------------------------------------------------------------------------// This method creates a new document and installs it into the application's// Apple Event Object Model hierarchy.PP_PowerPlant::LModelObject *CDocumentApp::MakeNewDocument(){	// refresh the data model and the palette	delete mData;	mData = new DM();		bunpal->updatePopupValues(); // BUNNY	// Make a new empty document.	bDoc = new CBunnyDoc( this, nil );	return bDoc;}// ---------------------------------------------------------------------------------//		¥ ChooseDocument// ---------------------------------------------------------------------------------// This method uses the PowerPlant Standard Dialogs to let the user choose a// document to open.voidCDocumentApp::ChooseDocument(){	PP_PowerPlant::PP_StandardDialogs::LFileChooser	chooser;		if (chooser.AskOpenFile(PP_PowerPlant::LFileTypeList(kBunnyDocFileType))) { // suz change		AEDescList		docList;		chooser.GetFileDescList(docList);		OpenOrPrintDocList(docList, PP_PowerPlant::ae_OpenDoc);	}}/* SelectOrCreate * -----------------   Given a window id, it will either create a new one or make it active. */LWindow *CDocumentApp::SelectOrCreate(int id, LCommander *commander) {	LWindow *theWindow = LWindow::FindWindowByID(id);	if (theWindow) {		theWindow->Select();	} else {		theWindow = LWindow::CreateWindow(id, commander);		ThrowIfNil_(theWindow);				// LWindow is not initially visible in PPob resource		theWindow->Show();	}		return theWindow;}/**************** Utility Functions ****************//* FindPaneInMyWindow * -----------------   Returns a pointer to a pane contained in the hierarchy of the    top-most window. */LPane *CDocumentApp::FindPaneInMyWindow(LPane *pane, int id) {	// get the top pane	LPane *top = GetTopPane(pane);	Assert_(top != NULL);	return top->FindPaneByID(id);}/* GetTopPane * -----------------   Recursive function to return pointer to the top pane. */LPane *CDocumentApp::GetTopPane(LPane *pane) {	LView *myParent = pane->GetSuperView();	if (myParent == NULL) return pane; 	else return GetTopPane(myParent);}/* Initialize * -----------------   When document initialized, create toolpalette */void CDocumentApp::Initialize() {/*	CScanner *cs = new CScanner("\pHellow, I      ;;;;;;;;;        like you","\p ;");	LStr255 s;	while (cs->ReadNextToken(s)) {		int i = 1;	}*/	// suz bunny	mData = new DM();	mFile = nil;	mDataBak = NULL;	// mData = NULL; // take care because don't want to delete junk later on		pal = (CToolPalette *) SelectOrCreate(kToolsWindowID, this);	bunpal = (CPalette *) SelectOrCreate(kBunPal,this);	catalogWin = (CCatalogWin *)SelectOrCreate(kCatalogWindowID,this);	catalog = catalogWin->getCatalog();	catalog->UpdateWholeList();		mPrefsFile = new LPreferencesFile("\pBunnyWorld Prefs",false);	}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	This method lets the application respond to commands like Menu commandsBooleanCDocumentApp::ObeyCommand(	PP_PowerPlant::CommandT	inCommand,	void					*ioParam){	Boolean		cmdHandled = true;	Int32 curPage;		if (mData->getTotalPages() > 1) {		((CBunnyDoc*) bDoc)->getCurrentPage(curPage);	} else {//you so don't want to know what I'm doing here. . .AJ 3/7		curPage = -5;	}	switch (inCommand) {			case wind_Inspector:			(bunpal->IsVisible()) ? bunpal->Hide() : bunpal->Show();			break;		case wind_Catalog:			(catalogWin->IsVisible()) ? catalogWin->Hide() : catalogWin->Show();			break;		case kNewPage:			JumpToPage(mData->getTotalPages() + 1);//this will need to be changed			break;					case cmd_Paste:			DoPaste();						break;			case wind_Palette:					(pal->IsVisible()) ? pal->Hide() : pal->Show();			break;		case kPlayMode:			SwitchPlayMode();			break;		case kNextPage:			curPage++;			JumpToPage(curPage);			break;		case kPrevPage:			curPage--;			JumpToPage(curPage);			break;		case cmd_Close:			playMode = false;			cmdHandled = PP_PowerPlant::LDocApplication::ObeyCommand(inCommand, ioParam);			break;		case cmd_Helpme:			SelectOrCreate(kHelpWindow,this);			break;		// Any that you don't handle, such as cmd_About and cmd_Quit,		// will be passed up to LApplication		default:			cmdHandled = PP_PowerPlant::LDocApplication::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	This function enables menu commands.//voidCDocumentApp::FindCommandStatus(	PP_PowerPlant::CommandT	inCommand,	Boolean					&outEnabled,	Boolean					&outUsesMark,	PP_PowerPlant::Char16	&outMark,	Str255					outName){	Int32 curPage;	if (mData->getTotalPages() > 1) {				((CBunnyDoc*) bDoc)->getCurrentPage(curPage);	} else {//you so don't want to know what I'm doing here. . .AJ 3/7		curPage = -5;	}	switch (inCommand) {			case wind_Palette:			outEnabled = (! inPlay());			if (pal->IsVisible()) { 				GetIndString(outName,kToolsTextID,kToolsTextHideIndex);			 } else {				GetIndString(outName,kToolsTextID,kToolsTextShowIndex);			 }			 			break;		case wind_Inspector:			outEnabled = (! inPlay());			if (bunpal->IsVisible()) { 				GetIndString(outName,kInspectorTextID,kInspectorTextHideIndex);			 } else {				GetIndString(outName,kInspectorTextID,kInspectorTextShowIndex);			 }			break;		case kNewPage:			outEnabled = (LWindow::FindWindowByID(kBunnyWindowID) != NULL);			if (playMode) outEnabled = false;			break;		case wind_Catalog:			outEnabled = (! inPlay());			if (catalogWin->IsVisible()) { 				GetIndString(outName,kCatalogTextID,kCatalogTextHideIndex);			 } else {				GetIndString(outName,kCatalogTextID,kCatalogTextShowIndex);			 }			break;		case kPlayMode:			if (inPlay()) { 				GetIndString(outName,kPlayModeTextID,kPlayModeEditTextIndex);			 } else {				GetIndString(outName,kPlayModeTextID,kPlayModePlayTextIndex);			 }			outEnabled = (! (LWindow::FindWindowByID(kBunnyWindowID) == NULL));			break;		case cmd_Paste:			long pictScrap = ::GetScrap(NULL, 'PICT', NULL);			long soundScrap = ::GetScrap(NULL, 'snd ', NULL);			outEnabled = (! inPlay() && (pictScrap > 0 || soundScrap > 0));			break;		case cmd_Open:		case cmd_New:			outEnabled = (! LWindow::FindWindowByID(kBunnyWindowID));			break;		case cmd_Clear:			outEnabled = false; // we don't clear, shapes do!!			break;				case kNextPage:			if (inPlay() || curPage == -5 || (LWindow::FindWindowByID(kBunnyWindowID) == NULL)) {				outEnabled = false;			} else {				outEnabled = (curPage < mData->getTotalPages()); // minus 1 reg, minus 2 in play (because of possessions window)			}			break;		case kPrevPage:			if (inPlay() || curPage == -5 || (LWindow::FindWindowByID(kBunnyWindowID) == NULL)) {				outEnabled = false;			} else {				outEnabled = (curPage > kStartPageNum);			}			break;		// Any that you don't handle, such as cmd_About and cmd_Quit,		// will be passed up to LApplication		case cmd_SaveAs://			outEnabled = (!inPlay() && LWindow::FindWindowByID(kBunnyWindowID));			outEnabled = (LWindow::FindWindowByID(kBunnyWindowID) != NULL);			break;				case cmd_Helpme:			outEnabled = true;			break;				default:			PP_PowerPlant::LDocApplication::FindCommandStatus(inCommand, outEnabled,												outUsesMark, outMark, outName);			break;	}}/* HandleKeyPress * -----------------   Added keyboard support for tool-switching */Boolean CDocumentApp::HandleKeyPress(	const EventRecord	&inKeyEvent){	bool keyHandled = true;	Char16 theKey = inKeyEvent.message;	// Added keyboard support for tool-switching	switch ((theKey & charCodeMask)) {		case kArrowChar:			GetPalettePtr()->SetToolID(kArrow);		break;		case kBoxChar:			GetPalettePtr()->SetToolID(kBox);		break;		default:			keyHandled = LCommander::HandleKeyPress((const EventRecord)inKeyEvent);		break;	}		return keyHandled;}/* ShowAboutBox * -----------------   Overrides the shows about box method. */void CDocumentApp::ShowAboutBox() {	SelectOrCreate(kAboutBox,this);}// get pointer to shape info// later becomes ref to data modelPicHandle CDocumentApp::getDataModel() {	return newPict;}void CDocumentApp::setDataModel(PicHandle handle) { 	if (! newPict) 	::ReleaseResource((Handle)newPict);	newPict = handle;}#pragma mark -#pragma mark === Bunny methods/*DM* CDocumentApp::getData() {	return dM;}//Added for testing of CCanvas AJ 3/1*/// ---------------------------------------------------------------------------//	¥ GetData// ---------------------------------------------------------------------------//DM* CDocumentApp::GetData() {	return mData;} LPane*  CDocumentApp::CreateCCanv(int numToAssign) {//Added for testing of CCanvas AJ 3/1	SPaneInfo inf;	SViewInfo inv;	inf.paneID = 150;	inf.width = kCanvasW;	inf.height = (inPlay() ? kCanvasHP : kCanvasHE);	inf.visible = true;	inf.enabled = true;	inf.bindings.left =			inf.bindings.right =			inf.bindings.top =			inf.bindings.bottom = false;			inf.left = 0;	inf.top = 0;	inf.userCon = 0;	inf.superView = LWindow::FindWindowByID(128);	SDimension32 im;	im.width = kCanvasW;	im.height = inf.height;	inv.imageSize = im;	SPoint32 iP, iX;//ugly, I know.  fuck you.	iP.h = 0;	iP.v = 0;	inv.scrollPos = iP;	iX.h = 1;	iX.v = 1;	inv.scrollUnit = iX;	inv.reconcileOverhang = false;	CCanvas *foo = new CCanvas (numToAssign, inf, inv);	return foo;}LPane*  CDocumentApp::CreateCPos() {//Added for testing of CPosessions AJ 3/2	SPaneInfo inf;	SViewInfo inv;	inf.paneID = 151;//called 151.  hard coded.  ugly.  change when this is decided	inf.width = kCanvasW;	inf.height = 100;	inf.visible = true;	inf.enabled = true;	inf.bindings.left =			inf.bindings.right =			inf.bindings.top =			inf.bindings.bottom = false;			inf.left = 0;	inf.top = kCanvasHE;	inf.userCon = 0;	inf.superView = LWindow::FindWindowByID(128);	SDimension32 im;	im.width = kCanvasW;	im.height = kCanvasHE;	inv.imageSize = im;	SPoint32 iP, iX;//ugly, I know.  fuck you.	iP.h = 0;	iP.v = 0;	inv.scrollPos = iP;	iX.h = 1;	iX.v = 1;	inv.scrollUnit = iX;	inv.reconcileOverhang = false;		Str255 canvasName;	LString::CopyPStr("\pPossessions",canvasName);	CPosessions *foo = new CPosessions (canvasName, inf, inv);//	delete canvasName;	return foo;}//Tells whether in play mode or notbool CDocumentApp::inPlay () {	return playMode;}void CDocumentApp::DoPaste() {/**********************************added clipboard code to work with Suzanne's***********************************/						Handle newHandle = ::NewHandle(1024);			long resultPict = ::GetScrap(newHandle, FOUR_CHAR_CODE('PICT'), NULL);			long resultSnd = ::GetScrap(newHandle, FOUR_CHAR_CODE('snd '),NULL);						// this is just a hack before we have a real place to put			// the pic handles.			if (resultPict>0 || resultSnd>0) {				AddResourceToDM((resultPict>0) ? 'PICT' : 'snd ',newHandle)	;					} else {				DisposeHandle(newHandle);			}/*******************************end of clipboard code********************************/}void CDocumentApp::AddResourceToDM(DataIDT type, Handle newHandle) {		int num = (type == 'PICT') ? mData->getTotalPicts() : mData->getTotalSounds();		LStr255 untitledString;				// find a unique name		// This is for the case where you have any number of untitled elements,		// then delete one, then insert one. You'd be overwriting the 		// name in that case. So we just loop & find the first unique name.				Store *store = NULL;				do {							untitledString = "\p";			untitledString = ((type == 'PICT') ? kUntitledPictString: kUntitledSoundString);			untitledString += "\p ";			num++;			untitledString += static_cast<SInt32>(num);			store = (type == 'PICT') ? mData->getPictResStore(untitledString) : 											mData->getSoundResStore(untitledString);		} while (store != NULL);								CResStore *newRes = (type == 'PICT') ? mData->newResStore(kPICT) :											 mData->newResStore(SOUND);		newRes->setHandle(newHandle);		newRes->setName(untitledString); 						// update the popup values to reflect it.		if (type == 'PICT') {			bunpal->updatePopupValues();			catalog->UpdatePicts();		} else {			catalog->UpdateSounds();		}}void CDocumentApp::DeleteShapeFromPage(StringPtr shapeName) {//is the page that the shape was 	// get page name	// get page store	// remove from DM	// if page store == current page on screen then redraw current page}bool CDocumentApp::JumpToPage(int pageToJump) {	CCanvas *curPage = (CCanvas*) LWindow::FindWindowByID(kBunnyWindowID)->FindPaneByID(kCanvasID);	if (pageToJump > (mData->getTotalPages() + 1) || pageToJump < 0) return false;	GetCPalettePtr()->setTargetShape(NULL);//	CCanvas *pos = (CCanvas*) LWindow::FindWindowByID(kBunnyWindowID)->FindPaneByID(151);	// crash happens here sja	curPage->DeleteMyself();//delete curPage;//curPage->removeMe();//hmmm. . .do we need this?//	pos = (CCanvas*) LWindow::FindWindowByID(kBunnyWindowID)->FindPaneByID(151);	curPage = (CCanvas*) CreateCCanv(pageToJump);	Assert_(curPage);//	curPage->FinishCreateSelf(); -- not needed	((CBunnyDoc*) bDoc)->SetCurrentPage(curPage);	curPage->PutInside(LWindow::FindWindowByID(kBunnyWindowID));	curPage->SetShapes();	curPage->Refresh();	SwitchTarget(curPage);	if (inPlay()) curPage->TellShapesEnter();	// sja			//UpdateMenus();	return true;	}bool CDocumentApp::JumpToPage(ConstStringPtr name) {	CPageStore* holder = mData->getPageStore(name);	Int32 pageNum;	if (holder == NULL) return false;	holder->getPage(pageNum);		return (JumpToPage(pageNum));}void CDocumentApp::getCurrentPageName(StringPtr pageName) {	Int32 pageNum;	if (LWindow::FindWindowByID(kBunnyWindowID)) {		((CBunnyDoc*) bDoc)->getCurrentPage(pageNum);		CPageStore *page = mData->getPageStore(pageNum);		page->getName(pageName);	} else {		pageName = "\p";	}}void CDocumentApp::getCurrentPageNum(Int32 &num) {	Int32 pageNum;	if (LWindow::FindWindowByID(kBunnyWindowID)) {		((CBunnyDoc*) bDoc)->getCurrentPage(pageNum);		num = pageNum;	} else {		num -1;	}}void CDocumentApp::SwitchPlayMode() {	playMode = (! inPlay());	FSSpec inFileSpec;	if (playMode) {		mDataBak = mData;				delete mFile;		mFile = nil;		mPrefsFile->GetSpecifier(inFileSpec);		OSErr whoCares = ::FSpDelete(&inFileSpec );/*		LWindow *win = LWindow::FindWindowByID(kBunnyWindowID);		win->Hide();		win->SetAttribute(windAttr_CloseBox);			win->Show();*/			// Make a new file object.		mFile = new PP_PowerPlant::LFileStream( inFileSpec );		// Get the proper file type.		OSType	theFileType = kBunnyPrefsType;		// Make new file on disk		mFile->CreateNewDataFile(kBunnyAppCreatorCode, theFileType, 0);	// data fork only		mData->WriteToFile((LFileStream*)mFile);		delete mFile;		/** opening **/	mData = new DM();		PP_PowerPlant::StDeleter<PP_PowerPlant::LFileStream>			theFile( new PP_PowerPlant::LFileStream( inFileSpec ) );			mData->ReadFromFile(theFile.Get()); // suzanne ?	mFile = theFile.Release();	// take over ownership of the file object		bunpal->Hide();	catalogWin->Hide();	pal->Hide();		} else {		delete mData;		mData = mDataBak;		mDataBak = NULL;		bunpal->Show();		catalogWin->Show();		pal->Show();			}	((CBunnyDoc*) bDoc)->HydrateFirstPage();	catalog->UpdateWholeList();		// make the canvas the new target		//	if (! playMode) SwitchTarget(((CCanvas *)FindPaneInMyWindow(LWindow::FindWindowByID(kBunnyWindowID),kCanvasID)));}void CDocumentApp::MakeEditMode() { 	playMode = false; 	mDataBak = NULL;	bunpal->Show();	catalogWin->Show();	pal->Show();}void CDocumentApp::SetDirty(bool dirty, bool override) { 	if (! inPlay() || override) {		mIsDirty = dirty; 	}}