#include "LString.h"class CScanner {public:	CScanner(StringPtr in, ConstStringPtr delimiters, ConstStringPtr skipset = "\p", 		const char repchar = '\0', bool lookLit = false, const char literal = '"') {		LString::CopyPStr(in,src,sizeof(Str255));		LString::CopyPStr(delimiters,delim,sizeof(Str255));		LString::CopyPStr(skipset,skip,sizeof(Str255));		index = 1;		LStr255 len(src);		srcLen = len.Length();		this->repchar = repchar;		lit = literal;		this->lookLit = lookLit;	}	bool ReadNextToken(LStr255& buffer){  char ch;	int count = 0;		bool litSearch = false;//literal search -- eg for quoted words "jdkd dlk"	/* This loop will first make sure that it hasn't maxed the buffer, *//* then check for delimiters, and lastly go ahead and put the char *//* into the buffer. */	buffer = "\p";  while (index <= srcLen) {	ch = src[index];	if (lookLit && ch == lit) {		litSearch = ! litSearch; // switch mode, 		index++;		continue; // don't keep char	}    if (IsInSet(ch,skip) && ! litSearch) {    	if (repchar != '\0') {    		src[index] = repchar;    	} else {    		index++;    	}    } else if (IsInSet(ch,delim) && ! litSearch) {		if (count == 0) {			index++;		} else if (count > 0) {			index++;				      break;		}    } else {		buffer.Append(ch);		index++;      count++;    }  }    return (index <= srcLen);}bool HasMoreTokens() { return (index <= srcLen); }bool IsInSet(char inch, Str255 set) {	LStr255 setL(set);	for (int i = 1; i <= setL.Length(); i++) {		char ch = set[i];		if (inch == ch) return true;	}	return false;}private:	Str255 src;	Str255 skip;	int index,srcLen;	Str255 delim;	char repchar,lit;	bool lookLit;};