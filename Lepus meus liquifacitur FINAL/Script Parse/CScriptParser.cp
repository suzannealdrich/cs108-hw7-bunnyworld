// CScriptParser.cp#include "CScriptParser.h"#include <LString.h>#include <ctype.h>	CScriptParser::CScriptParser(StringPtr script) {	LString::CopyPStr(script, mScript, sizeof(Str255));}Boolean CScriptParser::hasClick(TArray<CScriptAction*>& actions) {	return hasTarget(kTriggerClick,actions);}Boolean CScriptParser::hasDrop(StringPtr shapeName, TArray<CScriptAction*>& actions) {	return (hasTarget(kTriggerDrop,actions, true, shapeName));}Boolean CScriptParser::hasEnter(TArray<CScriptAction*>& actions) {	return hasTarget(kTriggerEnter,actions);}Boolean CScriptParser::hasTarget(ConstStringPtr target, TArray<CScriptAction*>& actions, bool hasQualifier, StringPtr qualifier) {		LStr255 line;	Boolean hasIt = false;	CScanner *cs = new CScanner(mScript,kLineDelim,kSkipDelim,kRepChar);	while (cs->HasMoreTokens()) {		cs->ReadNextToken(line);		LStr255 word;		CScanner *ws = new CScanner(line,kWordDelim,kSkipDelim,kRepChar, true);		ws->ReadNextToken(word); // this is "on"		if (::EqualString(word,"\pon",false,false)) {			ws->ReadNextToken(word); // this is the trigger name						if (::EqualString(word,target,false,false)) {				if (hasQualifier) { 					ws->ReadNextToken(word);					if (::EqualString(qualifier,word,false,false)) {						while (ws->HasMoreTokens()) {							CScriptAction *newAction = new CScriptAction(ws);							actions.AddItem(newAction);						}												hasIt = true;					}					//LString::CopyPStr(word,qualifier);				} else {					while (ws->HasMoreTokens()) {						CScriptAction *newAction = new CScriptAction(ws);						actions.AddItem(newAction);					}										hasIt = true;									}			}							}			delete ws;				}		delete cs;		return hasIt;}bool CScriptParser::IsNumber(StringPtr word) {	LStr255 wordSt(word);	for (int i = 1; i <= wordSt.Length(); i++) {		char ch = word[i];		if (! isdigit(ch)) return false;	}		return true;}Int32 CScriptParser::StringToNumber(StringPtr word) {	Int32 num;	::StringToNum(word,&num);	return num;}	/*	Int32 scriptIndex, clauseIndex = 0;		// just get first on click clause	if (getNextClause(mScript, scriptIndex, kCLICK, clause)) {		// maybe filter out on click text here?		while (getNextAction(clause, clauseIndex, action)) {			CScriptAction* clickAction(action);			actions->InsertItemsAt(1, LArray::index_Last, clickAction);		}	}		return (actions->GetCount() != 0)}Boolean CScriptParser::hasDrop(ConstStringPtr shapeName, TArray<CScriptAction*>& actions) {	// like hasClick but reads in multiple clauses, comparing	// shapeName to shape token after on drop to find right clause	// then filter out on drop and shape tokens and feed to getNextAction}Boolean CScriptParser::hasEnter(TArray<CScriptAction*>& actions) {	// like hasClick but reads in multiple clauses}Boolean CScriptParser::getNextClause(ConstStringPtr script, Int32& startIndex, 										ConstStringPtr key, StringPtr& outClause) {	Str255 currentClause, currentKey;	Int32 clauseIndex;	Boolean found;		while (getNextToken(string, startIndex, kSEMI, currentClause) {		// get a clause and see if it's the right one, set outClause to it		//getNextToken(currentClause, 0, kSPACE, currentKey);		//found = ::EqualString(currentKey, key, false, false)	}}	Boolean CScriptParser::getNextAction(ConstStringPtr clause, Int32& startIndex, 										StringPtr& outAction) {	// given a clause string with the trigger/trigger object filtered out,	// give back the next action string that either has a pair of words or beep}		Boolean CScriptParser::getNextToken(ConstStringPtr string, Int32& startIndex, 										ConstStringPtr delimeter, StringPtr& outToken); {	// set startIndex += Length(outToken)}	virtual Boolean getNextClause(ConstStringPtr string, Int32& startIndex, 									ConstStringPtr key, StringPtr& outClause);		virtual Boolean getNextAction(ConstStringPtr string, Int32& startIndex, 									StringPtr&outAction);		virtual Boolean getNextToken(ConstStringPtr string, Int32& startIndex, 									ConstStringPtr delimeter, StringPtr& outToken);*/