// DM.cp/* 96 Nov 20	Initial version	njp 97 Nov 16	Revised to use LStr255, the key name constants,  and DebugStateToString(). 99 Mar		Hacked for use in BunnyWorld sja*/#include "DM.h"#include <TArray.h>#include <TArrayIterator.h>#include "CPageStore.h"#include "CShapeStore.h"#include "CResStore.h"#include <UDebugging.h>DM::DM() {}DM::~DM() {	mPages.RemoveItemsAt(mPages.GetCount(), 1);	mShapes.RemoveItemsAt(mShapes.GetCount(), 1);	mPicts.RemoveItemsAt(mPicts.GetCount(), 1);	mSounds.RemoveItemsAt(mSounds.GetCount(), 1);}void DM::WriteToFile(LFileStream* file) {	Int32 count;		file->OpenDataFork(fsRdWrPerm);	count = mPages.GetCount();				// write the number of pages	file->WriteData(&count, sizeof(count));		TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	while (pagerator.Next(currentPage)) {		 currentPage->WriteToStream(file);	}		count = mShapes.GetCount();				// write the number of shapes	file->WriteData(&count, sizeof(count));		TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	while (shaperator.Next(currentShape)) {		 currentShape->WriteToStream(file);	}		count = mPicts.GetCount();				// write the number of picts	file->WriteData(&count, sizeof(count));		TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	while (picterator.Next(currentPict)) {		 currentPict->WriteToStream(file);	}		count = mSounds.GetCount();				// write the number of sounds	file->WriteData(&count, sizeof(count));		TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	while (sounderator.Next(currentSound)) {		 currentSound->WriteToStream(file);	}		file->SetLength(file->GetMarker());	file->CloseDataFork();}void DM::ReadFromFile(LFileStream* file) {	Int32 count, i;		mPages.RemoveItemsAt(mPages.GetCount(), 1);	mShapes.RemoveItemsAt(mShapes.GetCount(), 1);	mPicts.RemoveItemsAt(mPicts.GetCount(), 1);	mSounds.RemoveItemsAt(mSounds.GetCount(), 1);			file->OpenDataFork(fsRdPerm);			file->ReadData(&count, sizeof(Int32));	// read  the number of pages		for (i = 0; i < count; i++) {		CPageStore* currentPage = newPageStore();		currentPage->OrientFromStream(file);	}		file->ReadData(&count, sizeof(Int32));	// read  the number of shapes		for (i = 0; i < count; i++) {		CShapeStore* currentShape = newShapeStore();		currentShape->OrientFromStream(file);	}			file->ReadData(&count, sizeof(Int32));	// read  the number of picts		for (i = 0; i < count; i++) {		CResStore* currentPict = newResStore(PICT);		currentPict->OrientFromStream(file);	}			file->ReadData(&count, sizeof(Int32));	// read  the number of sounds		for (i = 0; i < count; i++) {		CResStore* currentSound = newResStore(SOUND);		currentSound->OrientFromStream(file);	}			file->CloseDataFork();}int DM::getTotalPages() {	return mPages.GetCount();}CPageStore* DM::newPageStore() {	CPageStore* page = new CPageStore();	mPages.AddItem(page);	return page;}CPageStore* DM::getPageStore(Int32 pageNum) {	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	Int32 currentNum;	while (pagerator.Next(currentPage)) {		currentPage->getPage(currentNum);		if (currentNum == pageNum) 			return currentPage;	}		return NULL;}CPageStore* DM::getPageStore(ConstStringPtr name) {	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	Str255 currentName;	while (pagerator.Next(currentPage)) {		currentPage->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) 			return currentPage;	}		return NULL;}TArray<CShapeStore*> DM::getShapesInPage(Int32 pageNum) {	TArray<CShapeStore*> pageShapes;		TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Int32 currentNum;	while (shaperator.Next(currentShape)) {		currentShape->getPage(currentNum);		if (currentNum == pageNum)  {			pageShapes.AddItem(currentShape);		}	}		return pageShapes;}void DM::removePageStore(Int32 pageNum) {	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	Int32 currentNum;	while (pagerator.Next(currentPage)) {		currentPage->getPage(currentNum);		if (currentNum == pageNum) {			mPages.RemoveItemsAt(1, pagerator.GetCurrentIndex());			delete currentPage;		}	}}int DM::getTotalShapes() {	return mShapes.GetCount();}CShapeStore* DM::newShapeStore() {	CShapeStore* shape = new CShapeStore();	mShapes.AddItem(shape);	return shape;}CShapeStore* DM::getShapeStore(ConstStringPtr name) {	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Str255 currentName;	while (shaperator.Next(currentShape)) {		currentShape->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false))			return currentShape;	}		return NULL;}void DM::removeShapeStore(ConstStringPtr name) {	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Str255 currentName;	while (shaperator.Next(currentShape)) {		currentShape->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) {			mShapes.RemoveItemsAt(1, shaperator.GetCurrentIndex());			delete currentShape;		}	}}int DM::getTotalPicts() {	return mPicts.GetCount();}int DM::getTotalSounds() {	return mSounds.GetCount();}CResStore* DM::newResStore(ConstStringPtr type) {	CResStore* res = new CResStore(type);	if (::EqualString(PICT, type, false, false)) {		mPicts.AddItem(res);	} else 	if (::EqualString(SOUND, type, false, false)) {		mSounds.AddItem(res);	}	return res;}CResStore* DM::getResStore(ConstStringPtr name) {	Str255 currentName;		TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	while (picterator.Next(currentPict)) {		currentPict->getName(currentName);		 if (currentName && ::EqualString(currentName, name, false, false)) 		 	return currentPict;	}		TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	while (sounderator.Next(currentSound)) {		currentSound->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) 			return currentSound;	}		return NULL;}TArray<CResStore*> DM::getResList() {	TArray<CResStore*> allRes;		TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	while (picterator.Next(currentPict)) {		 allRes.AddItem(currentPict);	}		TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	while (sounderator.Next(currentSound)) {		 allRes.AddItem(currentSound);	}		return allRes;}void DM::removeResStore(ConstStringPtr name) {	Str255 currentName;		TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	while (picterator.Next(currentPict)) {		currentPict->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) {			mPicts.RemoveItemsAt(1, picterator.GetCurrentIndex());			delete currentPict;		}		}		TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	while (sounderator.Next(currentSound)) {		currentSound->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) {			mSounds.RemoveItemsAt(1, sounderator.GetCurrentIndex());			delete currentSound;		}		}}