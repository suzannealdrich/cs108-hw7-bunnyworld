// =================================================================================//	CDocumentApp.cp					©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================//	This file contains the starter code for a document PowerPlant project////  The Application is derived from LDocApplication.  New Windows are managed//  by CTextDocument which is derived from LSingleDoc.  Each document contains//  a smart text view that remembers if it has changed since it was last saved.#include "CDocumentApp.h"#include <StandardFile.h>#include <LGrowZone.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <PPobClasses.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <URegistrar.h>#include <UTextTraits.h>#include <UStandardDialogs.h>#include <LWindow.h>#include <LCaption.h>#include "BunnyConstants.h"#include "CBunnyDoc.h"//#include "CPalette.h"#include "DM.h"#include "CPageStore.h"#include "CShapeStore.h"#include "CResStore.h"// =================================================================================//		¥ Main Program// ===========================================================================int main(){									SetDebugThrow_(PP_PowerPlant::debugAction_Alert);	// Set Debugging options	SetDebugSignal_(PP_PowerPlant::debugAction_Alert);	PP_PowerPlant::InitializeHeap(3);					// Initialize Memory Manager														// Parameter is number of Master Pointer														// blocks to allocate		PP_PowerPlant::UQDGlobals::InitializeToolbox(&qd);	// Initialize standard Toolbox managers		new PP_PowerPlant::LGrowZone(20000);				// Install a GrowZone function to catch														// low memory situations.	CDocumentApp	theApp;								// create instance of your application	theApp.Run();		return 0;}// ---------------------------------------------------------------------------------//		¥ CDocumentApp// ---------------------------------------------------------------------------------//	ConstructorCDocumentApp::CDocumentApp(){	RegisterClass_(PP_PowerPlant::LWindow);	RegisterClass_(PP_PowerPlant::LCaption);		PP_PowerPlant::PP_StandardDialogs::Load();		// Preload facilities for std dialogs			mData = new DM();}// ---------------------------------------------------------------------------------//		¥ ~CDocumentApp// ---------------------------------------------------------------------------------//	DestructorCDocumentApp::~CDocumentApp(){	PP_PowerPlant::PP_StandardDialogs::Unload();	// Clean up after std dialogs}// ---------------------------------------------------------------------------------//		¥ StartUp// ---------------------------------------------------------------------------------//	This function lets you do something when the application starts up//	without a document. For example, you could issue your own new command.voidCDocumentApp::StartUp(){	ObeyCommand( PP_PowerPlant::cmd_New, nil );}// ---------------------------------------------------------------------------//	¥ Initialize// ---------------------------------------------------------------------------//	Last chance to initialize the application before processing eventsvoid CDocumentApp::Initialize(){	//SelectOrCreateWindow(kPaletteID);	//mPalette = (CPalette*) PP_PowerPlant::LWindow::FindWindowByID(kPaletteID);	//Assert_(mPalette);}/*// ---------------------------------------------------------------------------//	¥ GetPalette// ---------------------------------------------------------------------------//	CPalette*CDocumentApp::GetPalette(){	return mPalette;}*/// ---------------------------------------------------------------------------//	¥ GetData// ---------------------------------------------------------------------------//DM* CDocumentApp::GetData() {	return mData;}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	This method lets the application respond to commands like Menu commandsBooleanCDocumentApp::ObeyCommand(	PP_PowerPlant::CommandT	inCommand,	void					*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) {						case cmd_ShowOrHidePalette:			//DoTogglePalette();			break;				case cmd_TestDataModel:			DoTestDataModel();			break;					default:			cmdHandled = PP_PowerPlant::LDocApplication::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	This function enables menu commands.voidCDocumentApp::FindCommandStatus(	PP_PowerPlant::CommandT	inCommand,	Boolean					&outEnabled,	Boolean					&outUsesMark,	PP_PowerPlant::Char16	&outMark,	Str255					outName){	switch (inCommand) {						case cmd_ShowOrHidePalette:			outEnabled = false;			//ResIDT index = (mPalette->IsVisible() ? HIDE_INDEX : SHOW_INDEX);			//::GetIndString(outName, kPaletteMenuStringsID, index);			break;					case cmd_TestDataModel:			outEnabled = true;			break;		default:			PP_PowerPlant::LDocApplication::FindCommandStatus(inCommand, outEnabled,												outUsesMark, outMark, outName);			break;	}}// ---------------------------------------------------------------------------//	¥ ShowAboutBox// ---------------------------------------------------------------------------//	Display the About Box for the applicationvoidCDocumentApp::ShowAboutBox(){	SelectOrCreateWindow(kAboutBoxID);}// ---------------------------------------------------------------------------------//		¥ OpenDocument// ---------------------------------------------------------------------------------// This method is called when a file is chosen from the StandardFile Open Dialog// File_Menu->Open item.voidCDocumentApp::OpenDocument(	FSSpec	*inMacFSSpec ){	PP_PowerPlant::LDocument	*theDoc = PP_PowerPlant::LDocument::FindByFileSpec(*inMacFSSpec);		// If the document is already open, make it the current document	if (theDoc != nil) {						theDoc->MakeCurrent();			// otherwise, make a new Document	} else {									theDoc = new CBunnyDoc(this, inMacFSSpec);	}}// ---------------------------------------------------------------------------------//		¥ MakeNewDocument// ---------------------------------------------------------------------------------// This method creates a new document and installs it into the application's// Apple Event Object Model hierarchy.PP_PowerPlant::LModelObject *CDocumentApp::MakeNewDocument(){	// Make a new empty document.	return new CBunnyDoc( this, nil );}// ---------------------------------------------------------------------------------//		¥ ChooseDocument// ---------------------------------------------------------------------------------// This method uses the PowerPlant Standard Dialogs to let the user choose a// document to open.voidCDocumentApp::ChooseDocument(){	PP_PowerPlant::PP_StandardDialogs::LFileChooser	chooser;		if (chooser.AskOpenFile(PP_PowerPlant::LFileTypeList(kBunnyDocFileType))) {		AEDescList		docList;		chooser.GetFileDescList(docList);		OpenOrPrintDocList(docList, PP_PowerPlant::ae_OpenDoc);	}}// ---------------------------------------------------------------------------------//		¥ SelectOrCreateWindow// ---------------------------------------------------------------------------------// void CDocumentApp::SelectOrCreateWindow(ResIDT id) {	PP_PowerPlant::LWindow* wind = PP_PowerPlant::LWindow::FindWindowByID(id);		if (wind) {		wind->Select();	} else {		PP_PowerPlant::LWindow* theWindow = PP_PowerPlant::LWindow::CreateWindow(id, this);		ThrowIfNil_(theWindow);		theWindow->Show();	}}// ---------------------------------------------------------------------------------//		¥ DoTogglePalette// ---------------------------------------------------------------------------------// void CDocumentApp::DoTogglePalette() {	/*	if (mPalette->IsVisible()) {		mPalette->Hide();	} else {		mPalette->Show();	}	*/}// ---------------------------------------------------------------------------------//		¥ DoTestDataModel// ---------------------------------------------------------------------------------// The following pretty much shows how to get what you need from the DM// and set it. If you think it is too hard to detect what the new name// of a page/shape/res should be, I could overload DM::newBlankStore()// or something... sjavoid CDocumentApp::DoTestDataModel() {	Str255 local;	Int32 num;	Point pt;	Boolean boole;	//PicHandle pictH;		PP_PowerPlant::LWindow* wind = PP_PowerPlant::LWindow::FindWindowByID(kBunnyWindowID);	LCaption* caption = (LCaption*) wind->FindPaneByID(kTestCaptionID);	LStr255 captionText;		// test pagestore		// create and orient		CPageStore* pageData;		pageData = mData->newPageStore();		pageData->setName("\pstart");	pageData->setPage(1);		// get and access	pageData = mData->getPageStore(1);	pageData = mData->getPageStore("\pstart");	Assert_(pageData);		pageData->getType(local);	captionText.Append(local);	captionText.Append("\p ");		pageData->getName(local);	captionText.Append(local);	captionText.Append("\p ");		pageData->getPage(num);	captionText.Append((long)num);	captionText.Append("\p * ");		// test shapestore		// create and orient		CShapeStore* shapeData;		shapeData = mData->newShapeStore();		shapeData->setName("\pbunny");	shapeData->setPage(1);	shapeData->setStart(kStartPt);	shapeData->setEnd(kEndPt);	shapeData->setMoveable(true);	shapeData->setVisible(true);	shapeData->setScript("\pon click beep;");	shapeData->setPict("\pbunnypict");		// get and access		shapeData = mData->getShapeStore("\pbunny");	Assert_(shapeData);		shapeData->getType(local);	captionText.Append(local);	captionText.Append("\p ");		shapeData->getName(local);	captionText.Append(local);	captionText.Append("\p ");		shapeData->getPage(num);	captionText.Append((long)num);	captionText.Append("\p ");		shapeData->getStart(pt);	captionText.Append(pt.h);	captionText.Append("\p ");	captionText.Append(pt.v);	captionText.Append("\p ");	shapeData->getEnd(pt);	captionText.Append(pt.h);	captionText.Append("\p ");	captionText.Append(pt.v);	captionText.Append("\p ");		shapeData->getMoveable(boole);	captionText.Append((boole? "\pT" : "\pF"));	captionText.Append("\p ");		shapeData->getVisible(boole);	captionText.Append((boole? "\pT" : "\pF"));	captionText.Append("\p ");			shapeData->getScript(local);	captionText.Append(local);	captionText.Append("\p ");		shapeData->getPict(local);	captionText.Append(local);	captionText.Append("\p * ");		// test resstore		// create and orient		CResStore* resData;		resData = mData->newResStore(PICT);		resData->setName("\pbunnypict");	//resData->setHandle();	// get and access		resData = mData->getResStore("\pbunnypict");	Assert_(resData);		resData->getType(local);	captionText.Append(local);	captionText.Append("\p ");		resData->getName(local);	captionText.Append(local);	captionText.Append("\p * ");		//resData->getHandle(pictH);		// test other stuff		//int num = getTotalPages();		//int num = getTotalShapes();		//int num = getTotalPicts();		//int num = getTotalSounds();		//TArray<CShapeStore*> shapes = getShapesInPage(1);		//TArray<CResStore*> resources = getResList();		caption->SetDescriptor(captionText);		mData->removePageStore(1);	mData->removeShapeStore("\pbunny");	mData->removeResStore("\pbunnypict");}