// =================================================================================//	CDocumentApp.cp					©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================//	This file contains the starter code for a document PowerPlant project////  The Application is derived from LDocApplication.  New Windows are managed//  by CTextDocument which is derived from LSingleDoc.  Each document contains//  a smart text view that remembers if it has changed since it was last saved.#include "CDocumentApp.h"#include <StandardFile.h>#include <LGrowZone.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <PPobClasses.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <URegistrar.h>#include <UTextTraits.h>#include <UStandardDialogs.h>// Appearance incs#include <LWindow.h>#include <LCaption.h>#include <UGraphicUtils.h>#include <UEnvironment.h>#include "UGAColorRamp.h"#include <LActiveScroller.h>#include <LWindow.h>#include <LPrintout.h>#include <LPlaceHolder.h>#include "CToolPaletteButton.h"#include "CCanvas.h"#include "MiniConstants.h"#include "LGAColorSwatchControl.h"#include "CSwatch.h"// Bunny Include#include <Appearance.h>#include <UControlRegistry.h>#include "CEditText.h"#include "CResDraw.h"#include "CEditField.h"#include "CPosessions.h"// Suz Bunny Include#include "CBunnyDoc.h"#include "DM.h"#include "CPageStore.h"#include "CShapeStore.h"#include "CResStore.h"// =================================================================================//		¥ Main Program// ===========================================================================int main(){									SetDebugThrow_(PP_PowerPlant::debugAction_Alert);	// Set Debugging options	SetDebugSignal_(PP_PowerPlant::debugAction_Alert);	PP_PowerPlant::InitializeHeap(3);					// Initialize Memory Manager														// Parameter is number of Master Pointer														// blocks to allocate		PP_PowerPlant::UQDGlobals::InitializeToolbox(&qd);	// Initialize standard Toolbox managers		new PP_PowerPlant::LGrowZone(20000);				// Install a GrowZone function to catch														// low memory situations.	CDocumentApp	theApp;								// create instance of your application	theApp.Run();		return 0;}// ---------------------------------------------------------------------------------//		¥ CDocumentApp// ---------------------------------------------------------------------------------//	ConstructorCDocumentApp::CDocumentApp(){	if ( PP_PowerPlant::UEnvironment::HasFeature( PP_PowerPlant::env_HasAppearance ) ) {		::RegisterAppearanceClient();	}	RegisterClass_(PP_PowerPlant::LWindow);			// You must register each kind of	RegisterClass_(PP_PowerPlant::LActiveScroller);	// PowerPlant classes that you use	RegisterClass_(PP_PowerPlant::LPrintout);		// in your PPob resource.	RegisterClass_(PP_PowerPlant::LPlaceHolder);	RegisterClass_(PP_PowerPlant::LRadioGroupView);	RegisterClass_(PP_PowerPlant::LGAColorSwatchControl);	RegisterClass_(PP_PowerPlant::LOffscreenView);			// Register the Appearance Manager/GA classes - bunny	// BUNNY START	PP_PowerPlant::UControlRegistry::RegisterClasses();	RegisterClass_(PP_PowerPlant::LView);	RegisterClass_(PP_PowerPlant::LEditField);	RegisterClass_(PP_PowerPlant::LPane);	RegisterClass_(CPalette);	RegisterClass_(CResDraw);	RegisterClass_(CEditField);		RegisterClass_(LTabGroup);	RegisterClass_(PP_PowerPlant::LTextEditView);	RegisterClass_(PP_PowerPlant::LPaintAttachment);	RegisterClass_(PP_PowerPlant::LBorderAttachment);	// BUNNY END	RegisterClass_(PP_PowerPlant::LPicture);	RegisterClass_(PP_PowerPlant::LCicnButton);	RegisterClass_(PP_PowerPlant::LStdButton);	RegisterClass_(PP_PowerPlant::LCaption);		RegisterClass_(CToolPalette);	RegisterClass_(CToolPaletteButton);	RegisterClass_(CCanvas);	RegisterClass_(CSwatch);	RegisterClass_(CEditText);				PP_PowerPlant::PP_StandardDialogs::Load();		// Preload facilities for std dialogs		//dM = new DMAp();//Added for testing of CCanvas AJ 3/1	playMode = false;}// ---------------------------------------------------------------------------------//		¥ ~CDocumentApp// ---------------------------------------------------------------------------------//	DestructorCDocumentApp::~CDocumentApp(){	PP_PowerPlant::PP_StandardDialogs::Unload();	// Clean up after std dialogs}// ---------------------------------------------------------------------------------//		¥ StartUp// ---------------------------------------------------------------------------------//	This function lets you do something when the application starts up//	without a document. For example, you could issue your own new command.voidCDocumentApp::StartUp(){// BUNNY: NO NEW FOR YOU!!!!//	ObeyCommand( PP_PowerPlant::cmd_New, nil );		// LDocApplication::ObeyCommand													// handles this command}// ---------------------------------------------------------------------------------//		¥ OpenDocument// ---------------------------------------------------------------------------------// This method is called when a file is chosen from the StandardFile Open Dialog// File_Menu->Open item.voidCDocumentApp::OpenDocument(	FSSpec	*inMacFSSpec ){	PP_PowerPlant::LDocument	*theDoc = PP_PowerPlant::LDocument::FindByFileSpec(*inMacFSSpec);		// If the document is already open, make it the current document	if (theDoc != nil) {						theDoc->MakeCurrent();			// otherwise, make a new Document	} else {									// refresh the data model and the palette		delete mData;		mData = new DM();		theDoc = new CBunnyDoc(this, inMacFSSpec);		bunpal->updatePopupValues(mData->getPictList()); // BUNNY	}			}// ---------------------------------------------------------------------------------//		¥ MakeNewDocument// ---------------------------------------------------------------------------------// This method creates a new document and installs it into the application's// Apple Event Object Model hierarchy.PP_PowerPlant::LModelObject *CDocumentApp::MakeNewDocument(){	// refresh the data model and the palette	delete mData;	mData = new DM();		bunpal->updatePopupValues(mData->getPictList()); // BUNNY	// Make a new empty document.	return new CBunnyDoc( this, nil );}// ---------------------------------------------------------------------------------//		¥ ChooseDocument// ---------------------------------------------------------------------------------// This method uses the PowerPlant Standard Dialogs to let the user choose a// document to open.voidCDocumentApp::ChooseDocument(){	PP_PowerPlant::PP_StandardDialogs::LFileChooser	chooser;		if (chooser.AskOpenFile(PP_PowerPlant::LFileTypeList(kBunnyDocFileType))) { // suz change		AEDescList		docList;		chooser.GetFileDescList(docList);		OpenOrPrintDocList(docList, PP_PowerPlant::ae_OpenDoc);	}}/* SelectOrCreate * -----------------   Given a window id, it will either create a new one or make it active. */LWindow *CDocumentApp::SelectOrCreate(int id, LCommander *commander) {	LWindow *theWindow = LWindow::FindWindowByID(id);	if (theWindow) {		theWindow->Select();	} else {		theWindow = LWindow::CreateWindow(id, commander);		ThrowIfNil_(theWindow);				// LWindow is not initially visible in PPob resource		theWindow->Show();	}		return theWindow;}/**************** Utility Functions ****************//* FindPaneInMyWindow * -----------------   Returns a pointer to a pane contained in the hierarchy of the    top-most window. */LPane *CDocumentApp::FindPaneInMyWindow(LPane *pane, int id) {	// get the top pane	LPane *top = GetTopPane(pane);	Assert_(top != NULL);	return top->FindPaneByID(id);}/* GetTopPane * -----------------   Recursive function to return pointer to the top pane. */LPane *CDocumentApp::GetTopPane(LPane *pane) {	LView *myParent = pane->GetSuperView();	if (myParent == NULL) return pane; 	else return GetTopPane(myParent);}/* Initialize * -----------------   When document initialized, create toolpalette */void CDocumentApp::Initialize() {	// suz bunny	mData = new DM();	// mData = NULL; // take care because don't want to delete junk later on		pal = (CToolPalette *) SelectOrCreate(kToolsWindowID, this);	bunpal = (CPalette *) SelectOrCreate(kBunPal,this);	}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	This method lets the application respond to commands like Menu commandsBooleanCDocumentApp::ObeyCommand(	PP_PowerPlant::CommandT	inCommand,	void					*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) {			case wind_Inspector:			(bunpal->IsVisible()) ? bunpal->Hide() : bunpal->Show();			break;		case cmd_Paste:/**********************************added clipboard code to work with Suzanne's***********************************/						Handle newPict = ::NewHandle(1024);			long result = ::GetScrap(newPict, FOUR_CHAR_CODE('PICT'), NULL);						// this is just a hack before we have a real place to put			// the pic handles.			if (result>0) {				int num = mData->getTotalPicts();				LStr255 *untitledString = NULL;								// find a unique name				// This is for the case where you have five untitled elements,				// then delete one, then insert one. You'd be overwriting the 				// name in that case. So we just loop & find the first unique name.								do {									delete untitledString;					untitledString = new LStr255(kUntitledString);					untitledString->Append("\p ");					untitledString->Append(static_cast<SInt32>(num));					num++;				} while (mData->getPictResStore(*untitledString) != NULL);												CResStore *newRes = mData->newResStore(kPICT);				newRes->setHandle(newPict);				newRes->setName(*untitledString); 								delete untitledString;								// update the popup values to reflect it.				bunpal->updatePopupValues(mData->getPictList());			} else {				DisposeHandle(newPict);			}/*******************************end of clipboard code********************************/						break;			case wind_Palette:					(pal->IsVisible()) ? pal->Hide() : pal->Show();			break;		// Any that you don't handle, such as cmd_About and cmd_Quit,		// will be passed up to LApplication		default:			cmdHandled = PP_PowerPlant::LDocApplication::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	This function enables menu commands.//voidCDocumentApp::FindCommandStatus(	PP_PowerPlant::CommandT	inCommand,	Boolean					&outEnabled,	Boolean					&outUsesMark,	PP_PowerPlant::Char16	&outMark,	Str255					outName){	switch (inCommand) {			case wind_Palette:			outEnabled = true;			if (pal->IsVisible()) { 				GetIndString(outName,kToolsTextID,kToolsTextHideIndex);			 } else {				GetIndString(outName,kToolsTextID,kToolsTextShowIndex);			 }			 			break;		case wind_Inspector:			if (bunpal->IsVisible()) { 				GetIndString(outName,kInspectorTextID,kInspectorTextHideIndex);			 } else {				GetIndString(outName,kInspectorTextID,kInspectorTextShowIndex);			 }			outEnabled = true;			break;		case cmd_Paste:			long scrap = ::GetScrap(NULL, 'PICT', NULL);			outEnabled = (scrap > 0);		break;		case cmd_Open:		case cmd_New:			outEnabled = (! LWindow::FindWindowByID(kBunnyWindowID));		break;		// Any that you don't handle, such as cmd_About and cmd_Quit,		// will be passed up to LApplication		default:			PP_PowerPlant::LDocApplication::FindCommandStatus(inCommand, outEnabled,												outUsesMark, outMark, outName);			break;	}}/* HandleKeyPress * -----------------   Added keyboard support for tool-switching */Boolean CDocumentApp::HandleKeyPress(	const EventRecord	&inKeyEvent){	bool keyHandled = true;	Char16 theKey = inKeyEvent.message;	// Added keyboard support for tool-switching	switch ((theKey & charCodeMask)) {		case kArrowChar:			GetPalettePtr()->SetToolID(kArrow);		break;		case kBoxChar:			GetPalettePtr()->SetToolID(kBox);		break;		default:			keyHandled = LCommander::HandleKeyPress((const EventRecord)inKeyEvent);		break;	}		return keyHandled;}/* ShowAboutBox * -----------------   Overrides the shows about box method. */void CDocumentApp::ShowAboutBox() {	SelectOrCreate(kAboutBox,this);}// get pointer to shape info// later becomes ref to data modelPicHandle CDocumentApp::getDataModel() {	return newPict;}void CDocumentApp::setDataModel(PicHandle handle) { 	if (! newPict) 	::ReleaseResource((Handle)newPict);	newPict = handle;}#pragma mark -#pragma mark === Bunny methods/*DM* CDocumentApp::getData() {	return dM;}//Added for testing of CCanvas AJ 3/1*/// ---------------------------------------------------------------------------//	¥ GetData// ---------------------------------------------------------------------------//DM* CDocumentApp::GetData() {	return mData;} LPane*  CDocumentApp::CreateCCanv() {//Added for testing of CCanvas AJ 3/1	SPaneInfo inf;	SViewInfo inv;	inf.paneID = 150;	inf.width = kCanvasW;	inf.height = kCanvasH;	inf.visible = true;	inf.enabled = true;	inf.bindings.left =			inf.bindings.right =			inf.bindings.top =			inf.bindings.bottom = false;			inf.left = 0;	inf.top = 0;	inf.userCon = 0;	inf.superView = LWindow::FindWindowByID(128);	SDimension32 im;	im.width = kCanvasW;	im.height = kCanvasH;	inv.imageSize = im;	SPoint32 iP, iX;//ugly, I know.  fuck you.	iP.h = 0;	iP.v = 0;	inv.scrollPos = iP;	iX.h = 1;	iX.v = 1;	inv.scrollUnit = iX;	inv.reconcileOverhang = false;		LStr255 *canvasName = new LStr255("bar");	CCanvas *foo = new CCanvas (*canvasName, inf, inv);	delete canvasName;	return foo;}LPane*  CDocumentApp::CreateCPos() {//Added for testing of CPosessions AJ 3/2	SPaneInfo inf;	SViewInfo inv;	inf.paneID = 151;//called 151.  hard coded.  ugly.  change when this is decided	inf.width = kCanvasW;	inf.height = 100;	inf.visible = true;	inf.enabled = true;	inf.bindings.left =			inf.bindings.right =			inf.bindings.top =			inf.bindings.bottom = false;			inf.left = 0;	inf.top = kCanvasH;	inf.userCon = 0;	inf.superView = LWindow::FindWindowByID(128);	SDimension32 im;	im.width = kCanvasW;	im.height = kCanvasH;	inv.imageSize = im;	SPoint32 iP, iX;//ugly, I know.  fuck you.	iP.h = 0;	iP.v = 0;	inv.scrollPos = iP;	iX.h = 1;	iX.v = 1;	inv.scrollUnit = iX;	inv.reconcileOverhang = false;		LStr255 *canvasName = new LStr255("bar");	CCanvas *foo = new CPosessions (*canvasName, inf, inv);	delete canvasName;	return foo;}//Tells whether in play mode or notbool CDocumentApp::inPlay () {	return playMode;}