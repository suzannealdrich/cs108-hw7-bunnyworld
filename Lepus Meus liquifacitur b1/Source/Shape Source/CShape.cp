#include "CShape.h"#include "CDrawUtils.h"#include "CDocumentApp.h"#include "CCanvas.h"#include "MiniConstants.h"#include "CSwatch.h"#include "CShapeAction.h"#include "CPosessions.h"// suz bunny include#include "CResStore.h"/* CShape * -----------------   Constructor; set start & end points */CShape::CShape(LStream *inStream) : LPane(inStream) {	Point temp;	temp.h = temp.v = 0;	sInfo = new CShapeStore();	sInfo->setStart(temp);	sInfo->setEnd(temp);	sInfo->setVisible(true);	sInfo->setMoveable(true);}/* CShape * -----------------   RT constructor */CShape::CShape(const CShapeInfo &shapeInfo) {	sInfo = new CShapeStore();	sInfo->setStart(shapeInfo.start);	sInfo->setEnd(shapeInfo.end);	sInfo->setVisible(true);	sInfo->setMoveable(true);		fillC = shapeInfo.fillC;	frameC = shapeInfo.frameC;	InitPane(shapeInfo.paneInfo);	pos =  GetSuperView()->GetSuperView()->FindPaneByID(151);//ugh. BUNNY	posessed = false;}/* FinishCreateSelf * -----------------   Add to the command hierarchy */void CShape::FinishCreateSelf() {CDocumentApp *app = (CDocumentApp *) GetTopCommander();	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);	SetSuperCommander((LCommander *)canvas);	LStr255 *defaultPict = new LStr255 (kDefaultMenuItem);	sInfo->setPict(*defaultPict);	delete defaultPict;		if (app->inPlay()) {		//do something	}}/* ShapeFrameRect * -----------------   Returns the exterior frame of the shape, which is a bit bigger than   the shape. */Rect CShape::ShapeFrameRect() {	Rect frame = ShapeRect();	::InsetRect(&frame,-(kKnobWidth/2.0),-(kKnobHeight/2.0));	return frame;}/* ShapeRect * -----------------   Returns the actual fram of the shape. */Rect CShape::ShapeRect() {	Rect frame;	Point start, end;	sInfo->getStart(start);	sInfo->getEnd(end);	CDrawUtils::CalcEnclosingRect(start, end,frame);	return frame;}/* DrawResizeKnobs * -----------------   Draw both knobs at once. */void CShape::DrawResizeKnobs() {	DrawResizeKnobStart();	DrawResizeKnobEnd();}/* DrawResizeKnobStart,DrawResizeKnobEnd * -----------------   Draw individual knobs */void CShape::DrawResizeKnobStart() { 	Point start;	sInfo->getStart(start);	DrawKnobHelper(start);}void CShape::DrawResizeKnobEnd() { 	Point end;	sInfo->getEnd(end);	DrawKnobHelper(end); }/* DrawKnobHelper * -----------------   Decomped helper function to draw both knobs */void CShape::DrawKnobHelper(Point startingPoint) {	Rect knob;	Point knobStart = startingPoint;	Point knobEnd = knobStart;		// Expand start & end points	knobEnd.h += kKnobWidth / 2.0;	knobEnd.v += kKnobHeight / 2.0;	knobStart.h -= kKnobHeight / 2.0;	knobStart.v -= kKnobHeight / 2.0;		// Get enclosing Rect	CDrawUtils::CalcEnclosingRect(knobStart,knobEnd,knob);		// paint	// BUNNY	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	(IsTarget()) ? ::RGBForeColor(&kBlackRGB) :  ::RGBForeColor(&kGreyRGB);//	::RGBForeColor(&kBlackRGB);	::FrameRect(&knob);	::PaintRect(&knob);}/* DrawSelf * -----------------   Generic drawself for all subclasses */void CShape::DrawSelf() {Rect shapeRect = ShapeRect();	::RGBForeColor(&frameC);	CResStore* rS;	PicHandle picture = NULL;	Handle temp = NULL;	Str255 picName = "\p";	DM* dM = ((CDocumentApp*) LCommander::GetTopCommander())->GetData();		sInfo->getPict(picName);	if (!::EqualString(picName, kDefaultMenuItemPtr, false, false)) {			rS = dM->getPictResStore(picName);		rS->getHandle(temp);		picture = (PicHandle) temp;		}	::RGBForeColor(&frameC);	::FrameRect(&shapeRect);	::RGBForeColor(&fillC);	::InsetRect(&shapeRect,1,1);	Boolean visible;	sInfo->getVisible(visible);	if (picture != NULL && visible) ::DrawPicture(picture, &shapeRect);		CDocumentApp *app = (CDocumentApp *) GetTopCommander();	if (IsTarget() ||		app->GetCPalettePtr()->getTargetShape() == this) {		DrawResizeKnobs();	}}/* DrawMyShape * -----------------   Let subclasses override this one */void CShape::DrawMyShape() {//nothing is really done.  in fact, this is never called.  hmmm./*	CResStore* rS;	PicHandle picture = NULL;	Handle temp = NULL;	Str255 picName = "\p";	DM* dM = ((CDocumentApp*) LCommander::GetTopCommander())->GetData();\			sInfo->getPict(picName);	if (picName != kDefaultMenuItemPtr) {			rS = dM->getResStore(picName);		rS->getHandle(temp);		picture = (PicHandle) temp;		}		Rect shapeRect = ShapeRect();	::RGBForeColor(&frameC);	::FrameRect(&shapeRect);	::RGBForeColor(&fillC);	::InsetRect(&shapeRect,1,1);	if (picture != NULL) ::DrawPicture(picture, &shapeRect);*/}/* BeTarget,DontBeTarget * -----------------   Always refresh when you're changing the target status */void CShape::BeTarget() {	// BUNNY	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	app->GetCPalettePtr()->setTargetShape(this);		Refresh();}void CShape::DontBeTarget() {	Refresh();}/* Resize * -----------------   Resize the object. Uses a helper function. */bool CShape::Resize(const SMouseDownEvent &inMouseDown, int whichKnob, bool isUndoable) {	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);	CShapeAction *action = new CShapeAction(this,kResizeID,true, canvas);	bool shifted = ShapeShifter(inMouseDown,true,whichKnob);	if (shifted && isUndoable) {		action->PostMyself();		canvas->SetDirty(true);	} else {		delete action;		// Must have been a creation		if (shifted && ! isUndoable) {			CShapeAction *action = new CShapeAction(this,kCreateID,true, canvas);			action->PostMyself();			canvas->SetDirty(true);		}			}	return shifted;}/* Move * -----------------   Move the shape. Uses helper function. */bool CShape::Move(const SMouseDownEvent &inMouseDown) {	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);	CShapeAction *action = new CShapeAction(this,kMoveID,true, canvas);	bool shifted = false;	Boolean moveable;	sInfo->getMoveable(moveable);	if (moveable) {		shifted = ShapeShifter(inMouseDown,false);	}		if (shifted) {		action->PostMyself();		canvas->SetDirty(true);	} else {		delete action;	}	return shifted;}/* SetStartEnd * -----------------   Sets the start and endpoint, and resizes the shape accordingly */void CShape::SetStartEnd(Point newStart, Point newEnd) {		if (newEnd.h > kCanvasW) newEnd.h = kCanvasW;	if (newEnd.h < 0) newEnd.h = 0;	if (newStart.h > kCanvasW) newStart.h = kCanvasW;	if (newStart.h < 0) newStart.h = 0;		if (!posessed) {		if (newStart.v < 0) newStart.v = 0;		if (newEnd.v < 0) newEnd.v = 0;		oldEndH = newEnd.h - newStart.h;		oldEndV = newEnd.v - newStart.v;	} else {		newEnd.h = newStart.h + 50;		newEnd.v = newStart.v + 50;	}	sInfo->setStart(newStart);	sInfo->setEnd(newEnd);		//WHAT IS THIS?	// get rect for exterior frame	Rect frame = ShapeFrameRect();	PlaceInSuperFrameAt(frame.left,frame.top,true);	ResizeFrameTo(frame.right - frame.left,				frame.bottom - frame.top,true);	}/* ShapeShifter * -----------------   "Shifts" the shape around the screen, either resizing or moving around   the screen. */bool CShape::ShapeShifter(const SMouseDownEvent &inMouseDown, bool considerKnob, int whichKnob) {	Point current,previous,newStart,newEnd;	bool resized;	int dh,dv;	bool p;	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);	LWindow *wind = (LWindow *)CDocumentApp::FindPaneInMyWindow(this,kCanvasWindow);	Rect windowBounds;	wind->GetGlobalBounds(windowBounds);		// Initialize the vars	dh = dv = 0;	current = inMouseDown.wherePort; 	resized = false;		sInfo->getStart(newStart);	sInfo->getEnd(newEnd);		SwitchTarget(GetTopCommander());	while (::StillDown()) {				previous = current;		wind->FocusDraw();		::GetMouse(&current);		 dh = current.h - previous.h;		 dv = current.v - previous.v;				 		// If mouse has changed at all		if (dh != 0 || dv != 0) {					p = ((CPosessions*) pos)->isInPosessions(current);			if (p) {				if (!posessed) {					Hide();					((CPosessions*)pos)->addItem(this);					canvas->RemoveShape(this);					posessed = true;//these will probably go through the dB.					Show();				//That's something to look at.					newStart.v -= kCanvasH;					newEnd.v -= kCanvasH;				}			} else {//more hacks!!  hurry up with the database. . .				if (posessed) {					Hide();					canvas->AddShape(this);				((CPosessions*)pos)->removeItem(this);					Show();					posessed = false;					newStart.v += kCanvasH;					newEnd.h = newStart.h + oldEndH;					newEnd.v = newStart.v + oldEndV;									}			}			// If we're not looking at knobs, or we are and its the 			// correct knob, then change the point			if (! considerKnob || whichKnob == kknobEnd) {				newEnd.h += dh;				newEnd.v += dv;			}						if (! considerKnob ||				whichKnob == kknobStart) {				newStart.h += dh;				newStart.v += dv;			}												SetStartEnd(newStart,newEnd);			Refresh();			UpdatePort();			resized = true;									// BUNNY			CDocumentApp *app = (CDocumentApp *) GetTopCommander();			app->GetCPalettePtr()->setTargetShape(this);		}	}	SwitchTarget(this);	return resized;}/* ObeyCommand * -----------------   Simple override of ObeyCommand to deal with the clear menu command. */Boolean CShape::ObeyCommand(	PP_PowerPlant::CommandT	inCommand,	void					*ioParam){	CShapeAction *action;	Boolean		cmdHandled = true;	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);		switch (inCommand) {		case cmd_Clear:			// Make an undoer action			action = new CShapeAction(this,kDeleteID,true, canvas);			action->PostMyself();			canvas->SetDirty(true);			DeleteMyself();			break;		default:			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}/* HandleKeyPress * -----------------   Handle when the delete key is pressed */Boolean CShape::HandleKeyPress(	const EventRecord	&inKeyEvent){	bool keyHandled = true;	Char16 theKey = inKeyEvent.message;	if ((theKey & charCodeMask) == char_Backspace) {		// Make an undoer action		CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);		CShapeAction *action = new CShapeAction(this,kDeleteID,true, canvas);		action->PostMyself();		DeleteMyself();	} else {		keyHandled = LCommander::HandleKeyPress(inKeyEvent);	}	return keyHandled;}/* FindCommandStatus * -----------------   Be sure to enable the clear menu command */void CShape::FindCommandStatus(	PP_PowerPlant::CommandT	inCommand,	Boolean					&outEnabled,	Boolean					&outUsesMark,	PP_PowerPlant::Char16	&outMark,	Str255					outName){	switch (inCommand) {			// Return menu item status according to command messages.		case PP_PowerPlant::cmd_Clear:			outEnabled = true;			break;	/*	case kSetFrameColor:		case kSetFillColor:			outEnabled = true;			break;*/		default:			LCommander::FindCommandStatus(inCommand, outEnabled,												outUsesMark, outMark, outName);			break;	}}/* ClickSelf * -----------------   Deal with clicks on the object */void CShape::ClickSelf(const SMouseDownEvent &inMouseDown) {	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	SMouseDownEvent lastMD = inMouseDown;	// Get a pointer to the canvas and the tool id	CCanvas *canvas = (CCanvas *)CDocumentApp::FindPaneInMyWindow(this,kCanvasID);	int tool = ((CDocumentApp *)GetTopCommander())->GetPalettePtr()->GetToolID();	if (!app->inPlay()) {		// Only care about arrow tool.		if (tool == kArrow) {			SwitchTarget(this);		// If it's on either knob, resize; else if it's on shape, move; else, let		// canvas deal with click.			if (IsClickOnKnob(kknobStart,inMouseDown.whereLocal)) {				Resize(inMouseDown, kknobStart, true);				return;			} else if (IsClickOnKnob(kknobEnd,inMouseDown.whereLocal)) {				Resize(inMouseDown, kknobEnd, true);				return;			} else if (IsClickOnObject(inMouseDown.whereLocal)) {				Move(inMouseDown);				return;			}					}			// Didn't like any of the other options, so send canvas click message.		Disable();		canvas->Click(lastMD);		Enable();	} else {		//do something	}}/* DeleteMyself * -----------------   Delete's this object. */void CShape::DeleteMyself() {		Hide(); // quick way to change command hierarchy & refresh	PutInside(nil); // remove it from window	delete this;}/* IsClickOnKnob,IsClickOnObject * -----------------   Tells if the click is on a given knob or object   Uses the Mac Toolbox region handles */bool CShape::IsClickOnKnob(int whichKnob, Point point) {	RgnHandle knobRgn = ::NewRgn();	::OpenRgn();	(whichKnob == kknobStart) ? DrawResizeKnobStart() :	DrawResizeKnobEnd();	::CloseRgn(knobRgn);	Boolean inShape = ::PtInRgn(point,knobRgn);	::DisposeRgn(knobRgn);	return inShape;	}bool CShape::IsClickOnObject(Point point) {	RgnHandle knobRgn = ::NewRgn();	::OpenRgn();	DrawSelf();	::CloseRgn(knobRgn);	Boolean inShape = ::PtInRgn(point,knobRgn);	::DisposeRgn(knobRgn);	return inShape;	}#pragma mark -#pragma mark === Unused functions/* SetFrameColor * -----------------   Sets the frame color */void CShape::SetFrameColor() {/*	RGBColor newColor;	if (GetNewColor(frameC,newColor)) {		frameC = newColor;		Refresh();	}*/}/* SetFillColor * -----------------   Sets the fill color */void CShape::SetFillColor() {/*	RGBColor newColor;	if (GetNewColor(fillC,newColor)) {		fillC = newColor;		Refresh();	}*/}/* GetNewColor * -----------------   Helper function to get a new color by prompting the user with an   LGA color selector thing. I copied this code from the LGAColorSelector */bool CShape::GetNewColor(RGBColor& inColor, RGBColor& outColor) {/*		Str255		prompt;		GetDescriptor ( prompt );		UDesktop::Deactivate ();		bool changed = ::GetColor ( Point_00, prompt, &inColor, &outColor);		UDesktop::Activate ();		return changed;*/return false;}#pragma mark -#pragma mark === Save & Undo Stuff/* GetInfo * -----------------   Gets shape info & returns in struct */void CShape::GetInfo(SShapeInfo& info) const {	sInfo->getStart(info.start);	sInfo->getEnd(info.end );		info.frameC = frameC;	info.fillC = fillC;}/* OrientFromInfo * -----------------   Adjusts shape provided info struct */void CShape::OrientFromInfo(const SShapeInfo info) {	SetStartEnd(info.start,info.end);		frameC = info.frameC;	fillC = info.fillC;		SwitchTarget(this);		Refresh();}/* WriteToStream * -----------------   Writes a shape to an LStream */void CShape::WriteToStream(LStream* inStream) {/*	SShapeInfo info;	GetInfo(info);	inStream->WriteData(&info,sizeof(info));*/}/* OrientFromStream * -----------------   Adjusts shape provided info struct-sized stream */void CShape::OrientFromStream(LStream* inStream) {/*	SShapeInfo info;	inStream->ReadData(&info,sizeof(info));	OrientFromInfo(info);*/}#pragma mark -#pragma mark === Bunny Methods//BUNNY CONSTRUCTORCShape::CShape(CShapeStore* info, CShapeInfo shapeInfo) {	sInfo = info;	fillC = shapeInfo.fillC;	frameC = shapeInfo.frameC;	pos =  GetSuperView()->GetSuperView()->FindPaneByID(151);//ugh.	InitPane(shapeInfo.paneInfo);}// BUNNY METHODSvoid CShape::getPicHandle(PicHandle &picture) {	CResStore* rS;//	PicHandle picture;	Handle temp;	LStr255 picName;	DM* dM = ((CDocumentApp*) LCommander::GetTopCommander())->GetData();		sInfo->getPict(picName);	rS = dM->getPictResStore(picName);	if (rS) {		rS->getHandle(temp);		picture = (PicHandle) temp;	} else {		picture = NULL;	}//	return picture;}void CShape::setPict(StringPtr newPic) {/*	LStr255 *foobar1 = new LStr255(kMenuItem1);	LStr255 *foobar2 = new LStr255(kMenuItem2);	LStr255 *foobar3 = new LStr255(kMenuItem3);	LStr255 *foobar4 = new LStr255(kMenuItem4);	::ReleaseResource((Handle)picture);	if (newPic == *foobar1) {		picture = (PicHandle)::Get1Resource('PICT',131);	} else if (newPic == *foobar2) {		picture = (PicHandle)::Get1Resource('PICT',132);		} else if (newPic == *foobar3) {		picture = (PicHandle)::Get1Resource('PICT',133);		} else if (newPic == *foobar4) {		picture = (PicHandle)::Get1Resource('PICT',134);		} else {		picture = NULL;	}			delete pictureName;		pictureName = newPic;		delete foobar1;	delete foobar2;	delete foobar3;	delete foobar4;*/	sInfo->setPict(newPic);	Refresh();}void CShape::getName(StringPtr name) {	sInfo->getName(name);}void CShape::getPageT(Int32& outPageNum) {	return sInfo->getPage(outPageNum);}void CShape::getStart(Point& pt) {	sInfo->getStart(pt);}void CShape::getEnd(Point& pt) {	sInfo->getEnd(pt);}void CShape::isMoveable(Boolean& isMoveable) {	sInfo->getMoveable(isMoveable);}void CShape::isVisible(Boolean& isVis) {	sInfo->getVisible(isVis);}void CShape::getScript(StringPtr script) {	sInfo->getScript(script);}void CShape::getPict(StringPtr pict) {	sInfo->getPict(pict);}void CShape::setStart(Point value) {	sInfo->setStart(value);}void CShape::setEnd(Point value) {	sInfo->setEnd(value);}void CShape::setPictT(StringPtr name) {	sInfo->setPict(name);}void CShape::setMoveable(bool moveable) {	sInfo->setMoveable(moveable);}void CShape::setScript(StringPtr script) {	sInfo->setScript(script);}void CShape::setPage(ResID id) {	sInfo->setPage(id);}void CShape::setVisible(bool isVisible) {	sInfo->setVisible(isVisible);	Refresh(); // have to refresh if changing visible state}void CShape::MovePane(bool toPos) {	if (toPos) {	//something	} else {	//something else;	}}void CShape::setName(StringPtr name) {	sInfo->setName(name);}