// DM.cp// Mar 99 - Hacked for BunnyWorld - sja#include "DM.h"#include <TArray.h>#include <TArrayIterator.h>#include "CPageStore.h"#include "CShapeStore.h"#include "CResStore.h"#include <UDebugging.h>// Constructor...nothing to doDM::DM() {}// Destructor...clean up arraysDM::~DM() {	removeAllStores();}// WriteToFile...write out length of each array followed by its storesvoid DM::WriteToFile(LFileStream* file) {	Int32 count;		file->OpenDataFork(fsRdWrPerm);	count = mPages.GetCount();				// write the number of pages	file->WriteData(&count, sizeof(count));		TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	while (pagerator.Next(currentPage)) {		 currentPage->WriteToStream(file);	}		count = mShapes.GetCount();				// write the number of shapes	file->WriteData(&count, sizeof(count));		TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	while (shaperator.Next(currentShape)) {		 currentShape->WriteToStream(file);	}		count = mPicts.GetCount();				// write the number of picts	file->WriteData(&count, sizeof(count));		TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	while (picterator.Next(currentPict)) {		 currentPict->WriteToStream(file);	}		count = mSounds.GetCount();				// write the number of sounds	file->WriteData(&count, sizeof(count));		TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	while (sounderator.Next(currentSound)) {		 currentSound->WriteToStream(file);	}		file->SetLength(file->GetMarker());	file->CloseDataFork();}// ReadFromFile...read in length of each array followed by its storesvoid DM::ReadFromFile(LFileStream* file) {	Int32 count, i;		removeAllStores();			file->OpenDataFork(fsRdPerm);			file->ReadData(&count, sizeof(Int32));	// read the number of pages		for (i = 0; i < count; i++) {		CPageStore* currentPage = newPageStore();		currentPage->OrientFromStream(file);	}		file->ReadData(&count, sizeof(Int32));	// read the number of shapes		for (i = 0; i < count; i++) {		CShapeStore* currentShape = newShapeStore();		currentShape->OrientFromStream(file);	}			file->ReadData(&count, sizeof(Int32));	// read the number of picts		for (i = 0; i < count; i++) {		CResStore* currentPict = newResStore(kPICT);		currentPict->OrientFromStream(file);	}			file->ReadData(&count, sizeof(Int32));	// read the number of sounds		for (i = 0; i < count; i++) {		CResStore* currentSound = newResStore(SOUND);		currentSound->OrientFromStream(file);	}			file->CloseDataFork();}// getTotalPages...return number of pagesint DM::getTotalPages() {	return mPages.GetCount();}// newPageStore...allocate page, enter it into mPages, and return pointerCPageStore* DM::newPageStore() {	CPageStore* page = new CPageStore();	mPages.AddItem(page);	return page;}// getPageStore...given its number, search for page in mPages and return pointer;// if not found return NULLCPageStore* DM::getPageStore(Int32 pageNum) {	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	Int32 currentNum;	while (pagerator.Next(currentPage)) {		currentPage->getPage(currentNum);		if (currentNum == pageNum) 			return currentPage;	}		return NULL;}// getPageStore...given its name, search for page in mPages and return pointer;// if not found return NULLCPageStore* DM::getPageStore(ConstStringPtr name) {	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	Str255 currentName;	while (pagerator.Next(currentPage)) {		currentPage->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) 			return currentPage;	}		return NULL;}// getShapesInPage...given its number, return array of pointers to shapes in that pageTArray<CShapeStore*> DM::getShapesInPage(Int32 pageNum) {	TArray<CShapeStore*> pageShapes;		TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Int32 currentNum;	while (shaperator.Next(currentShape)) {		currentShape->getPage(currentNum);		if (currentNum == pageNum)  {			pageShapes.AddItem(currentShape);		}	}		return pageShapes;}// getPageList...return array of pointers to all shapesTArray<CPageStore*> DM::getPageList() {	TArray<CPageStore*> allPages;	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	while (pagerator.Next(currentPage)) {		 allPages.AddItem(currentPage);	}		return allPages;}// removePageStore...given its number, delete page and its shapesvoid DM::removePageStore(Int32 pageNum) {	TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	Int32 currentNum;	while (pagerator.Next(currentPage)) {		currentPage->getPage(currentNum);		if (currentNum == pageNum) {			mPages.RemoveItemsAt(1, pagerator.GetCurrentIndex());			delete currentPage;		}	}		TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	while (shaperator.Next(currentShape)) {		currentShape->getPage(currentNum);		if (currentNum == pageNum)  {			mShapes.RemoveItemsAt(1, shaperator.GetCurrentIndex());			delete currentShape;		}	}}// getTotalShapes...return number of shapesint DM::getTotalShapes() {	return mShapes.GetCount();}// newShapeStore...allocate shape, enter it into mShapes, and return pointerCShapeStore* DM::newShapeStore() {	CShapeStore* shape = new CShapeStore();	mShapes.AddItem(shape);	return shape;}// getShapeStore...given its name, search for shape in mShapes and return pointer;// if not found return NULLCShapeStore* DM::getShapeStore(ConstStringPtr name) {	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Str255 currentName;	while (shaperator.Next(currentShape)) {		currentShape->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false))			return currentShape;	}		return NULL;}// getShapeList...return array of pointers to all shapesTArray<CShapeStore*> DM::getShapeList() {	TArray<CShapeStore*> allShapes;	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	while (shaperator.Next(currentShape)) {		 allShapes.AddItem(currentShape);	}		return allShapes;}// removeShapeStore...given its name, delete shapevoid DM::removeShapeStore(ConstStringPtr name) {	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	Str255 currentName;	while (shaperator.Next(currentShape)) {		currentShape->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) {			mShapes.RemoveItemsAt(1, shaperator.GetCurrentIndex());			delete currentShape;		}	}}// getTotalPicts...return number of picturesint DM::getTotalPicts() {	return mPicts.GetCount();}// getTotalSounds...return number of soundsint DM::getTotalSounds() {	return mSounds.GetCount();}// newResStore...allocate res, enter it into mPicts or mSounds, and return pointerCResStore* DM::newResStore(ConstStringPtr type) {	CResStore* res = new CResStore(type);	if (::EqualString(kPICT, type, false, false)) {		mPicts.AddItem(res);	} else 	if (::EqualString(SOUND, type, false, false)) {		mSounds.AddItem(res);	}	return res;}// getPictResStore...given its name, search for pict in mPicts and return pointer;// if not found return NULLCResStore* DM::getPictResStore(ConstStringPtr name) {	Str255 currentName;	TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	while (picterator.Next(currentPict)) {		currentPict->getName(currentName);		 if (currentName && ::EqualString(currentName, name, false, false)) 		 	return currentPict;	}		return NULL;}// getSoundResStore...given its name, search for sound in mSounds and return pointer;// if not found return NULLCResStore* DM::getSoundResStore(ConstStringPtr name) {	Str255 currentName;	TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	while (sounderator.Next(currentSound)) {		currentSound->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) 			return currentSound;	}		return NULL;}// getPictList...return array of pointers to all pictsTArray<CResStore*> DM::getPictList() {	TArray<CResStore*> allPicts;		TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	while (picterator.Next(currentPict)) {		 allPicts.AddItem(currentPict);	}		return allPicts;}// getResList...return array of pointers to all soundsTArray<CResStore*> DM::getSoundList() {	TArray<CResStore*> allSounds;		TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	while (sounderator.Next(currentSound)) {		 allSounds.AddItem(currentSound);	}		return allSounds;}// removeResStore...given its name, delete resvoid DM::removeResStore(ConstStringPtr name) {	Str255 currentName;		TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	while (picterator.Next(currentPict)) {		currentPict->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) {			mPicts.RemoveItemsAt(1, picterator.GetCurrentIndex());			delete currentPict;		}		}		TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	while (sounderator.Next(currentSound)) {		currentSound->getName(currentName);		if (currentName && ::EqualString(currentName, name, false, false)) {			mSounds.RemoveItemsAt(1, sounderator.GetCurrentIndex());			delete currentSound;		}		}}// removeAllStores...delete all storesvoid DM::removeAllStores() {	TArrayIterator<CShapeStore*> shaperator(mShapes);	CShapeStore* currentShape;	while (shaperator.Next(currentShape)) {		mShapes.RemoveItemsAt(1, shaperator.GetCurrentIndex());		delete currentShape;	}		TArrayIterator<CPageStore*> pagerator(mPages);	CPageStore* currentPage;	while (pagerator.Next(currentPage)) {		mPages.RemoveItemsAt(1, pagerator.GetCurrentIndex());		delete currentPage;	}		TArrayIterator<CResStore*> picterator(mPicts);	CResStore* currentPict;	while (picterator.Next(currentPict)) {		mPicts.RemoveItemsAt(1, picterator.GetCurrentIndex());		delete currentPict;	}		TArrayIterator<CResStore*> sounderator(mSounds);	CResStore* currentSound;	while (sounderator.Next(currentSound)) {		mSounds.RemoveItemsAt(1, sounderator.GetCurrentIndex());		delete currentSound;	}}