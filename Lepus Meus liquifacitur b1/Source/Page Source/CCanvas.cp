#include "CCanvas.h"#include "MiniConstants.h"//#include "CRect.h"#include "UCursor.h"//BUNNY#include "TArrayIterator.h"//#include "DMAp.h"#include "CShapeStore.h"#include "CPageStore.h"/* CCanvas * -----------------   Nothing special to do in stream constructor */CCanvas::CCanvas(LStream *inStream) : LOffscreenView(inStream) {	//thisPage = new CPageTest();//BUNNY	//int j = getPage();//BUNNY	}CCanvas::~CCanvas() {//Eventually gonna need some kind of delete fn.. .//BUNNY		app->GetCPalettePtr()->setTargetShape(NULL);}/* FinishCreateSelf * -----------------   Just get pointer to the application */void CCanvas::FinishCreateSelf() {	app = (CDocumentApp *)GetTopCommander();	AddAttachment( new LUndoer );	SetDirty(false);	SwitchTarget(this);}/* ClickSelf * -----------------   Defines action to take when canvas is clicked on */void CCanvas::ClickSelf(const SMouseDownEvent &inMouseDown) {	int tool = app->GetPalettePtr()->GetToolID();		// If tool not arrow, ie a drawing tool, then set cursor and	// follow the mouse	if (tool != kArrow) {		UCursor::SetCross();		if (::StillDown()) {			FollowTheMouse(inMouseDown, tool);		}		UCursor::SetArrow();	} else {		// clicked on blank part of canvas, so switch to top commander		SwitchTarget(this);	}	}/* FollowTheMouse * -----------------   Handles the series of events when a user clicks on the canvas */bool CCanvas::FollowTheMouse(const SMouseDownEvent &inMouseDown, int tool) {	CShape *newShape;		// make a new shape	newShape = NewShapeByClass(tool);	newShape->SetStartEnd(inMouseDown.whereLocal,inMouseDown.whereLocal);	Assert_(newShape != NULL);		// If it can resize the shape, then switch the target,	// else delete what was just created.	if (newShape->Resize(inMouseDown)) {		SwitchTarget(newShape);		return true;	} else {		delete newShape;	}	return false;}/* NewShapeByClass * -----------------   Creates a new run-time class given shape id. Really comes in handy */CShape *CCanvas::NewShapeByClass(int whichShape) {		// the SPaneInfo struct that the LPane needs		SPaneInfo paneInfo;		paneInfo.paneID = 0;		paneInfo.width = 0;		paneInfo.height = 0;		paneInfo.visible = true;		paneInfo.enabled = true;		paneInfo.bindings.left =			paneInfo.bindings.right =			paneInfo.bindings.top =			paneInfo.bindings.bottom = false;				paneInfo.left = 0;		paneInfo.top = 0;		paneInfo.userCon = 0;		paneInfo.superView = this;		// Fill in details for the CShapeInfo		CShapeInfo shapeInfo;				shapeInfo.start.h = shapeInfo.end.h = 0;		shapeInfo.start.v = shapeInfo.end.v = 0;		shapeInfo.frameC = app->GetPalettePtr()->GetFrameColor();		shapeInfo.fillC = app->GetPalettePtr()->GetForeColor();		shapeInfo.paneInfo = paneInfo;			switch(whichShape) {		case (kBox): // make a new box			CShape *rect = new CShape(shapeInfo);			rect->FinishCreate();			rect->Refresh();			return rect;		break;	}	// Don't know what to create, return null		return NULL;}//Decomped from NewShapeByClass, AJ 3/1CShapeInfo CCanvas::MakeInfo () {	SPaneInfo paneInfo;		paneInfo.paneID = 0;		paneInfo.width = 0;		paneInfo.height = 0;		paneInfo.visible = true;		paneInfo.enabled = true;		paneInfo.bindings.left =			paneInfo.bindings.right =			paneInfo.bindings.top =			paneInfo.bindings.bottom = false;				paneInfo.left = 0;		paneInfo.top = 0;		paneInfo.userCon = 0;		paneInfo.superView = this;		// Fill in details for the CShapeInfo		CShapeInfo shapeInfo;				shapeInfo.start.h = shapeInfo.end.h = 0;		shapeInfo.start.v = shapeInfo.end.v = 0;		shapeInfo.frameC = app->GetPalettePtr()->GetFrameColor();		shapeInfo.fillC = app->GetPalettePtr()->GetForeColor();		shapeInfo.paneInfo = paneInfo;		return shapeInfo;}#pragma mark -#pragma mark === Bunny added functions //BUNNY//Constructor  //APP needs to pass in all three for correct creation!!  AJ 3/1CCanvas::CCanvas (StringPtr name, const SPaneInfo &inPaneInfo,					const SViewInfo &inViewInfo) : LOffscreenView(inPaneInfo, inViewInfo) {	DM* dM;	CShapeStore* temp;	Int32 pageNum;		dM = ((CDocumentApp*) LCommander::GetTopCommander())->GetData();	thisPage = dM->getPageStore(name);	if (thisPage != NULL) {//Note: no RT error checking yet!!!		thisPage->getPage(pageNum);		TArray <CShapeStore*> shapes = dM->getShapesInPage(pageNum);//really does not mesh with the data model. . .issues, issues.		TArrayIterator<CShapeStore*> iterator(shapes);		while (iterator.Next(temp)) {			CShape* shape = new CShape(temp, MakeInfo());			shape->FinishCreateSelf();			shape->Refresh();//does this put inside msubpanes, et al???		}	} else {		thisPage = new CPageStore();	}}//Methodsvoid CCanvas::BeTarget() {	CDocumentApp *app = (CDocumentApp *) GetTopCommander();	app->GetCPalettePtr()->setTargetShape(NULL);}void CCanvas::getName(StringPtr outName) {	thisPage->getName(outName);}void CCanvas::getPage(Int32& pageNum) {	thisPage->getPage(pageNum);}void CCanvas::SetName(StringPtr name) {	thisPage->setName(name);}/*void  CCanvas::CreateNew(DM* inData) {	data = inData;	thisPage = new CPageTest();//will eventually be data->newCShapeStore();}void  CCanvas::OpenExisting(StringPtr name, DM* inData) {	/*TArrayIterator iterator;	CShapeStore* temp;	CShape* shape;	SPaneInfo paneInfo;		paneInfo.paneID = 0;		paneInfo.width = 0;		paneInfo.height = 0;		paneInfo.visible = true;		paneInfo.enabled = true;		paneInfo.bindings.left =			paneInfo.bindings.right =			paneInfo.bindings.top =			paneInfo.bindings.bottom = false;				paneInfo.left = 0;		paneInfo.top = 0;		paneInfo.userCon = 0;		paneInfo.superView = this;		// Fill in details for the CShapeInfo		CShapeInfo shapeInfo;				shapeInfo.start.h = shapeInfo.end.h = 0;		shapeInfo.start.v = shapeInfo.end.v = 0;		shapeInfo.frameC = app->GetPalettePtr()->GetFrameColor();		shapeInfo.fillC = app->GetPalettePtr()->GetForeColor();		shapeInfo.paneInfo = paneInfo;				data = inData;		while (iterator.Next(temp)) {		shape = new CShape(shapeInfo);		shape->CreateEx(temp, this);	}}*/void CCanvas::DrawSelf() {	Rect r;	CalcLocalFrameRect(r);	::FrameRect(&r);}void CCanvas::AddShape(CShape* item) {	item->PutInside(this);	Refresh();}void CCanvas::RemoveShape(CShape* item) {	//take it out of the data model}